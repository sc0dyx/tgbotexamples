# config.py

# –¢–æ–∫–µ–Ω –±–æ—Ç–∞ (–ª—É—á—à–µ —Ö—Ä–∞–Ω–∏—Ç—å –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è, –Ω–æ –¥–ª—è –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ –º–æ–∂–Ω–æ –ø—Ä—è–º–æ —Ç—É—Ç)
BOT_TOKEN = "8560376370:AAER8fgeUhtGJ4zHsQEqOYrK4NA5GJml5qc"
PAYMASTER_PROVIDER_TOKEN = "2051251535:TEST:OTk5MDA4ODgxLTAwNQ"

# –ü—É—Ç—å –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
DB_PATH = "database.db"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä—ã
DEFAULT_HP = 100
DEFAULT_MANA = 50
DEFAULT_GOLD = 0
DEFAULT_DIAMONDS = 0

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ (–º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å)
LOG_LEVEL = "INFO"
import asyncio
from aiogram import Bot, Dispatcher
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from config import BOT_TOKEN
from setup import Init
from handlers import start, profile, fight, shop, quests, inventory
from states.battleblock import router as rt


async def main():
    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã
    Init.setup_all()

    bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))

    dp = Dispatcher()

    # –ü–æ–¥–∫–ª—é—á–∞–µ–º —Ä–æ—É—Ç–µ—Ä—ã

    dp.include_router(rt)

    dp.include_router(start.router)
    dp.include_router(profile.router)
    dp.include_router(fight.router)
    dp.include_router(shop.router)
    dp.include_router(quests.router)
    dp.include_router(inventory.router)

    # –ó–∞–ø—É—Å–∫
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())
# setup.py (—Ñ—Ä–∞–≥–º–µ–Ω—Ç)

import sqlite3
from config import DB_PATH, DEFAULT_HP, DEFAULT_GOLD, DEFAULT_DIAMONDS, DEFAULT_MANA


class Init:
    @staticmethod
    def create_players():
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(f"""
            CREATE TABLE IF NOT EXISTS players (
                id INTEGER PRIMARY KEY,
                name TEXT,
                class TEXT,
                level INTEGER DEFAULT 1,
                hp INTEGER DEFAULT {DEFAULT_HP},
                max_hp INTEGER DEFAULT {DEFAULT_HP},
                max_inventory_slots INTEGER DEFAULT 20,
                mana INTEGER DEFAULT {DEFAULT_MANA},
                max_mana INTEGER DEFAULT {DEFAULT_MANA},
                exp INTEGER DEFAULT 0,
                gold INTEGER DEFAULT {DEFAULT_GOLD},
                diamonds INTEGER DEFAULT {DEFAULT_DIAMONDS}
            )
            """)
            conn.commit()

    @staticmethod
    def create_mobs():
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute("""
            CREATE TABLE IF NOT EXISTS mobs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                hp INTEGER,
                attack INTEGER,
                exp_reward INTEGER,
                gold_reward INTEGER,
                drop_item_id INTEGER
            )
            """)
            cur.execute("SELECT COUNT(*) FROM mobs")
            count = cur.fetchone()[0]
            if count == 0:
                cur.executemany(
                    """
                    INSERT INTO mobs (name, hp, attack, exp_reward, gold_reward, drop_item_id)
                    VALUES (?, ?, ?, ?, ?, ?)
                    """,
                    [
                        ("–°–ª–∏–∑–µ–Ω—å", 30, 5, 10, 5, None),
                        ("–ì–æ–±–ª–∏–Ω", 50, 10, 20, 10, None),
                        ("–û—Ä–∫", 80, 15, 30, 20, None),
                        ("–î—Ä–∞–∫–æ–Ω—á–∏–∫", 120, 20, 50, 50, None),
                    ],
                )
            conn.commit()

    @staticmethod
    def create_items():
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute("""
            CREATE TABLE IF NOT EXISTS items (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                type TEXT,
                power INTEGER,
                max_count INTEGER DEFAULT 9,
                price_gold INTEGER,
                price_diamonds INTEGER,
                usable_in_fight INTEGER DEFAULT 0,
                usable_in_profile INTEGER DEFAULT 0
            )
            """)
            cur.execute("SELECT COUNT(*) FROM items")
            count = cur.fetchone()[0]
            if count == 0:
                cur.executemany(
                    """
                    INSERT INTO items (name, type, power, max_count, price_gold, price_diamonds, usable_in_fight, usable_in_profile)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                    """,
                    [
                        # –ó–µ–ª—å—è: –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏ –≤ –±–æ—é, –∏ –≤ –ø—Ä–æ—Ñ–∏–ª–µ
                        ("–ó–µ–ª—å–µ –∑–¥–æ—Ä–æ–≤—å—è", "potion_hp", 50, 9, 20, 0, 1, 1),
                        ("–ó–µ–ª—å–µ –º–∞–Ω—ã", "potion_mana", 30, 9, 15, 0, 1, 1),
                        # –û—Ä—É–∂–∏–µ: –ª–µ–∂–∏—Ç –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ, –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é
                        ("–ú–µ—á", "weapon_warrior", 15, 1, 100, 0, 0, 0),
                        ("–í–æ–ª—à–µ–±–Ω–∞—è –ø–∞–ª–æ—á–∫–∞", "weapon_mage", 20, 1, 120, 0, 0, 0),
                        ("–ù–æ–∂", "weapon_rogue", 10, 1, 80, 0, 0, 0),
                        # –ë–æ–º–±–∞: –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –≤ –±–æ—é
                        ("–ë–æ–º–±–∞", "bomb", 100, 9, 0, 5, 1, 0),
                    ],
                )
            conn.commit()

    @staticmethod
    def create_inventory():
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute("""
            CREATE TABLE IF NOT EXISTS inventory (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                player_id INTEGER,
                item_id INTEGER,
                quantity INTEGER DEFAULT 1
            )
            """)
            conn.commit()

    @staticmethod
    def create_quests():
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute("""
            CREATE TABLE IF NOT EXISTS quests (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                description TEXT,
                reward_exp INTEGER,
                reward_gold INTEGER,
                reward_item_id INTEGER,
                condition_type TEXT NOT NULL,       -- kill_mob, collect_item, reach_level
                condition_target INTEGER NOT NULL,  -- mob_id / item_id / level
                condition_amount INTEGER DEFAULT 1
            )
            """)
            conn.commit()
            cur.execute("SELECT COUNT(*) FROM quests")
            count = cur.fetchone()[0]
            if count == 0:
                cur.executemany(
                    """
                    INSERT INTO quests (title, description, reward_exp, reward_gold, reward_item_id, condition_type, condition_target, condition_amount)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                    """,
                    [
                        (
                            "–ü–µ—Ä–≤—ã–π —à–∞–≥",
                            "–£–±–µ–π –ª—é–±–æ–≥–æ –º–æ–±–∞",
                            10,
                            5,
                            None,
                            "kill_mob",
                            0,
                            1,
                        ),
                        (
                            "–û—Ö–æ—Ç–∞ –Ω–∞ –≥–æ–±–ª–∏–Ω–∞",
                            "–ü–æ–±–µ–¥–∏ –≥–æ–±–ª–∏–Ω–∞",
                            20,
                            10,
                            None,
                            "kill_mob",
                            2,
                            1,
                        ),
                        (
                            "–°–∏–ª–∞ –æ—Ä–∫–∞",
                            "–°—Ä–∞–∑–∏—Å—å —Å –æ—Ä–∫–æ–º",
                            30,
                            20,
                            None,
                            "kill_mob",
                            3,
                            1,
                        ),
                        (
                            "–î—Ä–∞–∫–æ–Ω—å—è —É–≥—Ä–æ–∑–∞",
                            "–ü–æ–±–µ–¥–∏ –¥—Ä–∞–∫–æ–Ω—á–∏–∫–∞",
                            50,
                            50,
                            None,
                            "kill_m–æ–±",
                            4,
                            1,
                        ),
                    ],
                )
            conn.commit()

    @staticmethod
    def create_battles():
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute("""
            CREATE TABLE IF NOT EXISTS battles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                player_id INTEGER,
                mob_id INTEGER,
                mob_hp INTEGER,
                player_hp INTEGER,
                status TEXT DEFAULT 'active'
            )
            """)
            conn.commit()

    @staticmethod
    def create_player_quests():
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute("""
            CREATE TABLE IF NOT EXISTS player_quests (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                player_id INTEGER,
                quest_id INTEGER,
                status TEXT DEFAULT 'active',
                progress INTEGER DEFAULT 0
            )
            """)
            conn.commit()

    @staticmethod
    def setup_all():
        Init.create_players()
        Init.create_mobs()
        Init.create_items()
        Init.create_inventory()
        Init.create_quests()
        Init.create_battles()
        Init.create_player_quests()
        print("‚úÖ –í—Å–µ —Ç–∞–±–ª–∏—Ü—ã —Å–æ–∑–¥–∞–Ω—ã/–ø—Ä–æ–≤–µ—Ä–µ–Ω—ã!")
import sqlite3
from typing import Optional, List, Tuple
from config import DB_PATH, DEFAULT_HP, DEFAULT_MANA, DEFAULT_DIAMONDS, DEFAULT_GOLD


class Database:
    def __init__(self, path: str = DB_PATH):
        self.conn = sqlite3.connect(path)
        self.cur = self.conn.cursor()

    def execute(self, query: str, params: Tuple = ()):
        self.cur.execute(query, params)
        self.conn.commit()

    def fetchone(self, query: str, params: Tuple = ()):
        self.cur.execute(query, params)
        return self.cur.fetchone()

    def fetchall(self, query: str, params: Tuple = ()):
        self.cur.execute(query, params)
        return self.cur.fetchall()


# ------------------ Players ------------------
class PlayerRepo:
    def __init__(self, db: Database):
        self.db = db

    def add_player(self, player_id: int, name: str, player_class: str):
        self.db.execute(
            """INSERT INTO players 
            (id, name, class, level, hp, max_hp, mana, max_mana, exp, gold, diamonds, max_inventory_slots)
            VALUES (?, ?, ?, 1, ?, ?, ?, ?, 0, ?, ?, 20)""",
            (
                player_id,
                name,
                player_class,
                DEFAULT_HP,
                DEFAULT_HP,
                DEFAULT_MANA,
                DEFAULT_MANA,
                DEFAULT_GOLD,
                DEFAULT_DIAMONDS,
            ),
        )

    def get_player(self, player_id: int) -> Optional[Tuple]:
        return self.db.fetchone("SELECT * FROM players WHERE id=?", (player_id,))

    def update_hp(self, player_id: int, new_hp: int):
        self.db.execute("UPDATE players SET hp=? WHERE id=?", (new_hp, player_id))

    def update_gold(self, player_id: int, amount: int):
        self.db.execute(
            "UPDATE players SET gold = gold + ? WHERE id=?", (amount, player_id)
        )

    def update_diamonds(self, player_id: int, amount: int):
        self.db.execute(
            "UPDATE players SET diamonds = diamonds + ? WHERE id=?", (amount, player_id)
        )


# ------------------ Mobs ------------------
class MobRepo:
    def __init__(self, db: Database):
        self.db = db

    def list_mobs(self) -> List[Tuple]:
        return self.db.fetchall("SELECT * FROM mobs")

    def get_mob(self, mob_id: int) -> Optional[Tuple]:
        return self.db.fetchone("SELECT * FROM mobs WHERE id=?", (mob_id,))


# ------------------ Items ------------------
class ItemRepo:
    def __init__(self, db: Database):
        self.db = db

    def list_items(self) -> List[Tuple]:
        return self.db.fetchall("SELECT * FROM items")

    def get_item(self, item_id: int) -> Optional[Tuple]:
        return self.db.fetchone("SELECT * FROM items WHERE id=?", (item_id,))


# ------------------ Inventory ------------------
class InventoryRepo:
    def __init__(self, db: Database):
        self.db = db

    def add_item_to_player(self, player_id: int, item_id: int, quantity: int = 1):
        # –£–∑–Ω–∞—ë–º max_count –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞
        item = self.db.fetchone("SELECT max_count FROM items WHERE id=?", (item_id,))
        max_count = item[0] if item else 9

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø—Ä–µ–¥–º–µ—Ç —É –∏–≥—Ä–æ–∫–∞
        existing = self.db.fetchone(
            "SELECT id, quantity FROM inventory WHERE player_id=? AND item_id=? ORDER BY id DESC",
            (player_id, item_id),
        )

        if existing:
            inv_id, current_qty = existing
            new_qty = current_qty + quantity

            if new_qty <= max_count:
                # –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
                self.db.execute(
                    "UPDATE inventory SET quantity=? WHERE id=?", (new_qty, inv_id)
                )
            else:
                # –∑–∞–ø–æ–ª–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π —Å—Ç–∞–∫ –¥–æ –º–∞–∫—Å–∏–º—É–º–∞
                self.db.execute(
                    "UPDATE inventory SET quantity=? WHERE id=?", (max_count, inv_id)
                )
                # –æ—Å—Ç–∞—Ç–æ–∫ –∏–¥—ë—Ç –≤ –Ω–æ–≤—ã–π —Å—Ç–∞–∫
                leftover = new_qty - max_count
                self.db.execute(
                    "INSERT INTO inventory (player_id, item_id, quantity) VALUES (?, ?, ?)",
                    (player_id, item_id, leftover),
                )
        else:
            # –µ—Å–ª–∏ –ø—Ä–µ–¥–º–µ—Ç–∞ –Ω–µ—Ç –≤–æ–æ–±—â–µ ‚Äî —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π —Å—Ç–∞–∫
            self.db.execute(
                "INSERT INTO inventory (player_id, item_id, quantity) VALUES (?, ?, ?)",
                (player_id, item_id, min(quantity, max_count)),
            )
            leftover = quantity - max_count
            while leftover > 0:
                qty = min(leftover, max_count)
                self.db.execute(
                    "INSERT INTO inventory (player_id, item_id, quantity) VALUES (?, ?, ?)",
                    (player_id, item_id, qty),
                )
                leftover -= qty

    def get_inventory(self, player_id: int) -> List[Tuple]:
        return self.db.fetchall(
            "SELECT * FROM inventory WHERE player_id=?", (player_id,)
        )

    def get_player_items(self, player_id: int) -> List[Tuple]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –∏–≥—Ä–æ–∫–∞ —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º, —Ç–∏–ø–æ–º, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –∏ —Ñ–ª–∞–≥–∞–º–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è.
        –§–æ—Ä–º–∞—Ç: (item_id, name, type, quantity, usable_in_fight, usable_in_profile)
        """
        return self.db.fetchall(
            """
            SELECT items.id, items.name, items.type, inventory.quantity,
                items.usable_in_fight, items.usable_in_profile
            FROM inventory
            JOIN items ON inventory.item_id = items.id
            WHERE inventory.player_id=?
            """,
            (player_id,),
        )


# ------------------ Quests ------------------
class QuestRepo:
    def __init__(self, db: Database):
        self.db = db

    def list_quests(self) -> List[Tuple]:
        return self.db.fetchall("SELECT * FROM quests")

    def get_quest(self, quest_id: int) -> Optional[Tuple]:
        return self.db.fetchone("SELECT * FROM quests WHERE id=?", (quest_id,))
# utils/leveling.py

import math
from utils.db import Database, PlayerRepo
from config import DB_PATH

db = Database(DB_PATH)
player_repo = PlayerRepo(db)


def exp_required(level: int) -> int:
    base = 50
    p = 2
    scale = 5
    m = 0.1
    return int(base * (level**p) + scale * math.exp(m * level))


def check_level_up(player_id: int):
    player = player_repo.get_player(player_id)
    level = player[3]  # –ø–æ–ª–µ level
    exp = player[9]  # –ø–æ–ª–µ exp
    max_hp = player[5]  # max_hp
    max_mana = player[8]  # max_mana

    while exp >= exp_required(level):
        exp -= exp_required(level)
        level += 1
        max_hp += 10
        max_mana += 5

        # –∞–ø–¥–µ–π—Ç: —É—Ä–æ–≤–µ–Ω—å, –æ–ø—ã—Ç, –º–∞–∫—Å HP/MP –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ
        db.execute(
            "UPDATE players SET level=?, exp=?, max_hp=?, hp=?, max_mana=?, mana=? WHERE id=?",
            (level, exp, max_hp, max_hp, max_mana, max_mana, player_id),
        )
# utils/quest_logic.py

from utils.db import Database, QuestRepo, PlayerRepo, InventoryRepo
from config import DB_PATH

db = Database(DB_PATH)
quest_repo = QuestRepo(db)
player_repo = PlayerRepo(db)
inventory_repo = InventoryRepo(db)


def complete_quest(player_id: int, quest_id: int) -> str:
    quest = quest_repo.get_quest(quest_id)
    (
        _,
        title,
        _,
        reward_exp,
        reward_gold,
        reward_item_id,
        _,
        _,
        _,
    ) = quest

    db.execute(
        "UPDATE player_quests SET status='completed' WHERE player_id=? AND quest_id=?",
        (player_id, quest_id),
    )

    player_repo.update_gold(player_id, reward_gold)
    db.execute("UPDATE players SET exp = exp + ? WHERE id=?", (reward_exp, player_id))
    if reward_item_id:
        inventory_repo.add_item_to_player(player_id, reward_item_id, 1)

    return f"üéâ –ö–≤–µ—Å—Ç '{title}' –≤—ã–ø–æ–ª–Ω–µ–Ω!\nüìà EXP: {reward_exp}\nüí∞ Gold: {reward_gold}"


def check_quests(player_id: int, event_type: str, target_id: int, amount: int = 1):
    """
    event_type: 'kill_mob' | 'collect_item' | 'reach_level'
    target_id: mob_id / item_id / level
    amount: –ø—Ä–æ–≥—Ä–µ—Å—Å, –¥–æ–±–∞–≤–ª—è–µ–º—ã–π –∑–∞ —Å–æ–±—ã—Ç–∏–µ
    """
    active = db.fetchall(
        """
        SELECT pq.quest_id, pq.progress, q.condition_type, q.condition_target, q.condition_amount
        FROM player_quests AS pq
        JOIN quests AS q ON pq.quest_id = q.id
        WHERE pq.player_id=? AND pq.status='active'
        """,
        (player_id,),
    )

    messages = []
    for quest_id, progress, cond_type, target, cond_amount in active:
        if cond_type != event_type:
            continue
        if cond_type == "kill_mob":
            if target == 0 or target == target_id:  # 0 = –ª—é–±–æ–π –º–æ–±
                progress += amount
        elif cond_type == "collect_item":
            if target == target_id:
                progress += amount
        elif cond_type == "reach_level":
            # –¥–ª—è reach_level –Ω–µ—Ç –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è: –ø—Ä–æ–≤–µ—Ä—è–µ–º —É—Ä–æ–≤–µ–Ω—å –Ω–∞–ø—Ä—è–º—É—é
            if target_id >= target:
                progress = cond_amount

        # —Å–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
        db.execute(
            "UPDATE player_quests SET progress=? WHERE player_id=? AND quest_id=?",
            (progress, player_id, quest_id),
        )

        # –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ
        if progress >= cond_amount:
            messages.append(complete_quest(player_id, quest_id))

    return messages
# handlers/fight.py

import random
from aiogram import Router, types, F
from aiogram.utils.keyboard import InlineKeyboardBuilder
from states.battleblock import BattleBlock
from aiogram.fsm.context import FSMContext
from utils.db import Database, PlayerRepo, MobRepo, InventoryRepo
from utils.quest_logic import check_quests
from config import DB_PATH
from utils.leveling import check_level_up

SPELL_COST = 10

router = Router()
db = Database(DB_PATH)
player_repo = PlayerRepo(db)
mob_repo = MobRepo(db)
inventory_repo = InventoryRepo(db)


def victory_menu():
    kb = InlineKeyboardBuilder()
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu:back")
    kb.button(text="‚û°Ô∏è –°–ª–µ–¥—É—é—â–∏–π", callback_data="fight:start")
    kb.adjust(2)
    return kb.as_markup()


def fight_menu():
    kb = InlineKeyboardBuilder()
    kb.button(text="‚öîÔ∏è –ê—Ç–∞–∫–∞", callback_data="fight:attack")
    kb.button(text="üõ°Ô∏è –ó–∞—â–∏—Ç–∞", callback_data="fight:defend")
    kb.button(text="üîÆ –ú–∞–≥–∏—è", callback_data="fight:magic")
    kb.button(text="üì¶ –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å", callback_data="inventory:battle")
    kb.adjust(2)
    return kb.as_markup()


async def fight_defeat(
    callback: types.CallbackQuery, player, battle_id, name, mob_dmg, text
):
    db.execute("UPDATE battles SET status='finished' WHERE id=?", (battle_id,))
    db.execute(
        "UPDATE players SET hp = max_hp, mana = max_mana, exp = 0 WHERE id=?",
        (player[0],),
    )
    lost_gold = int(player[10] * 0.2)
    db.execute("UPDATE players SET gold = gold - ? WHERE id=?", (lost_gold, player[0]))
    await callback.message.edit_text(
        text + f"üëä {name} –Ω–∞–Ω—ë—Å {mob_dmg}.\nüíÄ –¢—ã –ø—Ä–æ–∏–≥—Ä–∞–ª!\n"
        f"‚ù§Ô∏è HP –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –¥–æ {player[5]}.\n"
        f"üí∞ –ü–æ—Ç–µ—Ä—è–Ω–æ {lost_gold} –∑–æ–ª–æ—Ç–∞.\n"
        f"üìà –û–ø—ã—Ç –æ–±–Ω—É–ª—ë–Ω.",
        reply_markup=victory_menu(),
    )


@router.callback_query(F.data == "fight:start")
async def start_fight(callback: types.CallbackQuery, state: FSMContext):
    player = player_repo.get_player(callback.from_user.id)
    if not player:
        await callback.answer("–°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Å—è!", show_alert=True)
        return

    # –ó–∞–≤–µ—Ä—à–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –±–æ–∏
    db.execute(
        "UPDATE battles SET status='finished' WHERE player_id=? AND status='active'",
        (player[0],),
    )

    mobs = mob_repo.list_mobs()
    if not mobs:
        await callback.answer("–ù–µ—Ç –º–æ–±–æ–≤ –≤ –±–∞–∑–µ!", show_alert=True)
        return

    mob = random.choice(mobs)
    mob_id, name, hp, attack, exp_reward, gold_reward, drop_item_id = mob

    db.execute(
        "INSERT INTO battles (player_id, mob_id, mob_hp, player_hp, status) VALUES (?, ?, ?, ?, 'active')",
        (player[0], mob_id, hp, player[4]),
    )
    await state.set_state(BattleBlock.active)
    mana, max_mana = player[7], player[8]
    await callback.message.edit_text(
        f"‚öîÔ∏è –¢—ã –≤—Å—Ç—Ä–µ—Ç–∏–ª {name}!\n"
        f"‚ù§Ô∏è HP –º–æ–±–∞: {hp}\n"
        f"üîÆ –¢–≤–æ—è –º–∞–Ω–∞: {mana}/{max_mana}\n"
        f"–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=fight_menu(),
    )


@router.callback_query(F.data == "fight:attack")
async def player_attack(callback: types.CallbackQuery, state: FSMContext):
    player = player_repo.get_player(callback.from_user.id)
    battle = db.fetchone(
        "SELECT id, mob_id, mob_hp, player_hp FROM battles WHERE player_id=? AND status='active'",
        (player[0],),
    )
    if not battle:
        await callback.answer("–ë–æ–π –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
        return

    battle_id, mob_id, mob_hp, player_hp = battle
    mob = mob_repo.get_mob(mob_id)
    _, name, _, attack, exp_reward, gold_reward, drop_item_id = mob

    dmg = random.randint(5, 15)
    mob_hp = max(mob_hp - dmg, 0)
    text = f"‚öîÔ∏è –¢—ã —É–¥–∞—Ä–∏–ª {name} –Ω–∞ {dmg}!\n"

    if mob_hp <= 0:
        player_repo.update_gold(player[0], gold_reward)
        db.execute("UPDATE battles SET status='finished' WHERE id=?", (battle_id,))
        db.execute(
            "UPDATE players SET exp = exp + ? WHERE id=?", (exp_reward, player[0])
        )
        check_level_up(player[0])
        await state.clear()
        drop_text = ""
        if drop_item_id:
            inventory_repo.add_item_to_player(player[0], drop_item_id, 1)
            item = db.fetchone("SELECT name FROM items WHERE id=?", (drop_item_id,))
            drop_text = (
                f"\nüéÅ –í—ã–ø–∞–ª –ø—Ä–µ–¥–º–µ—Ç: {item[0]}" if item else "\nüéÅ –í—ã–ø–∞–ª –ø—Ä–µ–¥–º–µ—Ç!"
            )

        # –û–±–Ω–æ–≤–ª—è–µ–º –º–∞–Ω–∞ –∏–∑ –±–∞–∑—ã (–Ω–µ –º–µ–Ω—è–ª–∞—Å—å, –Ω–æ –±–µ—Ä—ë–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è)
        mana, max_mana = player[7], player[8]
        await callback.message.edit_text(
            text + f"üéâ –ü–æ–±–µ–¥–∞ –Ω–∞–¥ {name}!\n"
            f"üìà EXP: {exp_reward}\n"
            f"üí∞ Gold: {gold_reward}\n"
            f"üîÆ –¢–≤–æ—è –º–∞–Ω–∞: {mana}/{max_mana}"
            f"{drop_text}",
            reply_markup=victory_menu(),
        )

        messages = check_quests(player[0], "kill_mob", mob_id, 1)
        for msg in messages:
            await callback.message.answer(msg)
        return

    # –û—Ç–≤–µ—Ç –º–æ–±–∞
    mob_dmg = random.randint(1, attack)
    player_hp = max(player_hp - mob_dmg, 0)
    player_repo.update_hp(player[0], player_hp)

    mana, max_mana = player[7], player[8]
    if player_hp <= 0:
        await fight_defeat(callback, player, battle_id, name, mob_dmg, text)
        await state.clear()
    else:
        db.execute(
            "UPDATE battles SET mob_hp=?, player_hp=? WHERE id=?",
            (mob_hp, player_hp, battle_id),
        )
        await callback.message.edit_text(
            text + f"üëä {name} –æ—Ç–≤–µ—Ç–∏–ª –∏ –Ω–∞–Ω—ë—Å {mob_dmg}.\n"
            f"‚ù§Ô∏è –¢–≤–æ—ë HP: {player_hp}/{player[5]}\n"
            f"üíÄ HP –º–æ–±–∞: {mob_hp}\n"
            f"üîÆ –¢–≤–æ—è –º–∞–Ω–∞: {mana}/{max_mana}\n"
            f"–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=fight_menu(),
        )


@router.callback_query(F.data == "fight:magic")
async def player_magic(callback: types.CallbackQuery, state: FSMContext):
    player = player_repo.get_player(callback.from_user.id)
    if not player:
        await callback.answer("–°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Å—è!", show_alert=True)
        return

    battle = db.fetchone(
        "SELECT id, mob_id, mob_hp, player_hp FROM battles WHERE player_id=? AND status='active'",
        (player[0],),
    )
    if not battle:
        await callback.answer("–ë–æ–π –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
        return

    battle_id, mob_id, mob_hp, player_hp = battle
    mob = mob_repo.get_mob(mob_id)
    _, name, _, attack, exp_reward, gold_reward, drop_item_id = mob

    mana, max_mana = player[7], player[8]
    if mana < SPELL_COST:
        await callback.answer(
            f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã (–Ω—É–∂–Ω–æ {SPELL_COST})!", show_alert=True
        )
        return

    dmg = random.randint(15, 30)
    mob_hp = max(mob_hp - dmg, 0)

    # –°–ø–∏—Å—ã–≤–∞–µ–º –º–∞–Ω—É –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
    mana = max(mana - SPELL_COST, 0)
    db.execute("UPDATE players SET mana=? WHERE id=?", (mana, player[0]))

    text = f"üîÆ –¢—ã –∏—Å–ø–æ–ª—å–∑—É–µ—à—å –º–∞–≥–∏—é –∏ –Ω–∞–Ω–æ—Å–∏—à—å {dmg} —É—Ä–æ–Ω–∞ {name}!\n"

    if mob_hp <= 0:
        player_repo.update_gold(player[0], gold_reward)
        db.execute("UPDATE battles SET status='finished' WHERE id=?", (battle_id,))
        db.execute(
            "UPDATE players SET exp = exp + ? WHERE id=?", (exp_reward, player[0])
        )
        check_level_up(player[0])
        await state.clear()
        drop_text = ""
        if drop_item_id:
            inventory_repo.add_item_to_player(player[0], drop_item_id, 1)
            item = db.fetchone("SELECT name FROM items WHERE id=?", (drop_item_id,))
            drop_text = (
                f"\nüéÅ –í—ã–ø–∞–ª –ø—Ä–µ–¥–º–µ—Ç: {item[0]}" if item else "\nüéÅ –í—ã–ø–∞–ª –ø—Ä–µ–¥–º–µ—Ç!"
            )

        await callback.message.edit_text(
            text + f"üéâ –ü–æ–±–µ–¥–∞ –Ω–∞–¥ {name}!\n"
            f"üìà EXP: {exp_reward}\n"
            f"üí∞ Gold: {gold_reward}\n"
            f"üîÆ –¢–≤–æ—è –º–∞–Ω–∞: {mana}/{max_mana}"
            f"{drop_text}",
            reply_markup=victory_menu(),
        )

        messages = check_quests(player[0], "kill_mob", mob_id, 1)
        for msg in messages:
            await callback.message.answer(msg)
        return

    mob_dmg = random.randint(1, attack)
    player_hp = max(player_hp - mob_dmg, 0)
    player_repo.update_hp(player[0], player_hp)

    if player_hp <= 0:
        await fight_defeat(callback, player, battle_id, name, mob_dmg, text)
        await state.clear()
    else:
        db.execute(
            "UPDATE battles SET mob_hp=?, player_hp=? WHERE id=?",
            (mob_hp, player_hp, battle_id),
        )
        await callback.message.edit_text(
            text + f"üëä {name} –æ—Ç–≤–µ—Ç–∏–ª –∏ –Ω–∞–Ω—ë—Å {mob_dmg}.\n"
            f"‚ù§Ô∏è –¢–≤–æ—ë HP: {player_hp}/{player[5]}\n"
            f"üíÄ HP –º–æ–±–∞: {mob_hp}\n"
            f"üîÆ –¢–≤–æ—è –º–∞–Ω–∞: {mana}/{max_mana}\n"
            f"–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=fight_menu(),
        )


@router.callback_query(F.data == "fight:defend")
async def player_defend(callback: types.CallbackQuery, state: FSMContext):
    player = player_repo.get_player(callback.from_user.id)
    battle = db.fetchone(
        "SELECT id, mob_id, mob_hp, player_hp FROM battles WHERE player_id=? AND status='active'",
        (player[0],),
    )
    if not battle:
        await callback.answer("–ë–æ–π –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
        return

    battle_id, mob_id, mob_hp, player_hp = battle
    mob = mob_repo.get_mob(mob_id)
    _, name, _, attack, exp_reward, gold_reward, drop_item_id = mob

    # –ó–∞—â–∏—Ç–∞: –º–∞–ª—ã–π —É—Ä–æ–Ω –∏–≥—Ä–æ–∫–∞, —É–º–µ–Ω—å—à–µ–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç –º–æ–±–∞
    dmg = random.randint(3, 8)
    mob_hp = max(mob_hp - dmg, 0)

    mob_dmg = max(random.randint(1, attack) // 2, 0)
    player_hp = max(player_hp - mob_dmg, 0)
    player_repo.update_hp(player[0], player_hp)

    text = f"üõ°Ô∏è –¢—ã –∑–∞—â–∏—â–∞–µ—à—å—Å—è –∏ –Ω–∞–Ω–æ—Å–∏—à—å {dmg} —É—Ä–æ–Ω–∞ {name}!\n"

    if mob_hp <= 0:
        player_repo.update_gold(player[0], gold_reward)
        db.execute("UPDATE battles SET status='finished' WHERE id=?", (battle_id,))
        db.execute(
            "UPDATE players SET exp = exp + ? WHERE id=?", (exp_reward, player[0])
        )
        check_level_up(player[0])

        await state.clear()
        drop_text = ""
        if drop_item_id:
            inventory_repo.add_item_to_player(player[0], drop_item_id, 1)
            item = db.fetchone("SELECT name FROM items WHERE id=?", (drop_item_id,))
            drop_text = (
                f"\nüéÅ –í—ã–ø–∞–ª –ø—Ä–µ–¥–º–µ—Ç: {item[0]}" if item else "\nüéÅ –í—ã–ø–∞–ª –ø—Ä–µ–¥–º–µ—Ç!"
            )

        mana, max_mana = player[7], player[8]
        await callback.message.edit_text(
            text + f"üéâ –ü–æ–±–µ–¥–∞ –Ω–∞–¥ {name}!\n"
            f"üìà EXP: {exp_reward}\n"
            f"üí∞ Gold: {gold_reward}\n"
            f"üîÆ –¢–≤–æ—è –º–∞–Ω–∞: {mana}/{max_mana}"
            f"{drop_text}",
            reply_markup=victory_menu(),
        )

        messages = check_quests(player[0], "kill_mob", mob_id, 1)
        for msg in messages:
            await callback.message.answer(msg)
        return

    mana, max_mana = player[7], player[8]
    if player_hp <= 0:
        await fight_defeat(callback, player, battle_id, name, mob_dmg, text)
        await state.clear()
    else:
        db.execute(
            "UPDATE battles SET mob_hp=?, player_hp=? WHERE id=?",
            (mob_hp, player_hp, battle_id),
        )
        await callback.message.edit_text(
            text + f"üëä {name} –∞—Ç–∞–∫—É–µ—Ç, –Ω–æ —Ç–≤–æ—è –∑–∞—â–∏—Ç–∞ —Å–Ω–∏–∂–∞–µ—Ç —É—Ä–æ–Ω!\n"
            f"‚ù§Ô∏è –¢–≤–æ—ë HP: {player_hp}/{player[5]}\n"
            f"üíÄ HP –º–æ–±–∞: {mob_hp}\n"
            f"üîÆ –¢–≤–æ—è –º–∞–Ω–∞: {mana}/{max_mana}\n"
            f"–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=fight_menu(),
        )


@router.callback_query(F.data == "fight:menu")
async def fight_menu_back(callback: types.CallbackQuery):
    player = player_repo.get_player(callback.from_user.id)
    battle = db.fetchone(
        "SELECT mob_id, mob_hp, player_hp FROM battles WHERE player_id=? AND status='active'",
        (player[0],),
    )
    if not battle:
        await callback.answer("–ë–æ–π –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
        return

    mob_id, mob_hp, player_hp = battle
    mob = mob_repo.get_mob(mob_id)
    _, name, _, attack, _, _, _ = mob

    mana, max_mana = player[7], player[8]
    await callback.message.edit_text(
        f"‚öîÔ∏è –¢—ã –ø—Ä–æ–¥–æ–ª–∂–∞–µ—à—å –±–æ–π —Å {name}!\n"
        f"‚ù§Ô∏è –¢–≤–æ—ë HP: {player_hp}/{player[5]}\n"
        f"üíÄ HP –º–æ–±–∞: {mob_hp}\n"
        f"üîÆ –¢–≤–æ—è –º–∞–Ω–∞: {mana}/{max_mana}\n"
        f"–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=fight_menu(),
    )
from aiogram import Router, types, F
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
import random
from utils.db import Database, ItemRepo, InventoryRepo, PlayerRepo
from config import DB_PATH
from utils.leveling import check_level_up

router = Router()
db = Database(DB_PATH)
item_repo = ItemRepo(db)
inventory_repo = InventoryRepo(db)
player_repo = PlayerRepo(db)


def fight_menu_inline():
    kb = InlineKeyboardBuilder()
    kb.button(text="‚öîÔ∏è –ê—Ç–∞–∫–∞", callback_data="fight:attack")
    kb.button(text="üõ°Ô∏è –ó–∞—â–∏—Ç–∞", callback_data="fight:defend")
    kb.button(text="üîÆ –ú–∞–≥–∏—è", callback_data="fight:magic")
    kb.button(text="üì¶ –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å", callback_data="inventory:battle")
    kb.adjust(2)
    return kb.as_markup()


def victory_menu_inline():
    kb = InlineKeyboardBuilder()
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu:back")
    kb.button(text="‚û°Ô∏è –°–ª–µ–¥—É—é—â–∏–π", callback_data="fight:start")
    kb.adjust(2)
    return kb.as_markup()


# ---------- –ü—Ä–æ—Ñ–∏–ª—å–Ω—ã–π –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å ----------
@router.callback_query(F.data == "inventory:profile")
async def inventory_profile(callback: types.CallbackQuery):
    player = player_repo.get_player(callback.from_user.id)
    items = inventory_repo.get_player_items(player[0])

    if not items:
        # –µ—Å–ª–∏ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø—É—Å—Ç ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –Ω–∞–∑–∞–¥
        kb = InlineKeyboardBuilder()
        kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="profile:show")
        await callback.message.edit_text(
            "üì¶ –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø—É—Å—Ç!", reply_markup=kb.as_markup()
        )
        return

    kb = InlineKeyboardBuilder()
    text = "üì¶ –¢–≤–æ–π –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å:\n"
    for item_id, name, type_, qty, usable_in_fight, usable_in_profile in items:
        text += f"\n{name} x{qty}"
        if usable_in_profile:
            kb.button(
                text=f"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å {name}",
                callback_data=f"inventory:use:{item_id}:profile",
            )
        kb.button(text=f"–ü—Ä–æ–¥–∞—Ç—å {name}", callback_data=f"inventory:sell:{item_id}")
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="profile:show")
    kb.adjust(2)
    await callback.message.edit_text(text, reply_markup=kb.as_markup())


# ---------- –ë–æ–µ–≤–æ–π –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å ----------
@router.callback_query(F.data == "inventory:battle")
async def inventory_battle(callback: types.CallbackQuery):
    player = player_repo.get_player(callback.from_user.id)
    items = inventory_repo.get_player_items(player[0])

    if not items:
        # –µ—Å–ª–∏ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø—É—Å—Ç ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –Ω–∞–∑–∞–¥ –≤ –±–æ–π
        kb = InlineKeyboardBuilder()
        kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="fight:menu")
        await callback.message.edit_text(
            "üì¶ –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø—É—Å—Ç!", reply_markup=kb.as_markup()
        )
        return

    kb = InlineKeyboardBuilder()
    text = "‚öîÔ∏è –ë–æ–µ–≤–æ–π –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å:\n"
    for item_id, name, type_, qty, usable_in_fight, usable_in_profile in items:
        text += f"\n{name} x{qty}"
        if usable_in_fight:
            kb.button(
                text=f"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å {name}",
                callback_data=f"inventory:use:{item_id}:battle",
            )
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="fight:menu")
    kb.adjust(1)
    await callback.message.edit_text(text, reply_markup=kb.as_markup())


# ---------- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø—Ä–µ–¥–º–µ—Ç–æ–≤ ----------
@router.callback_query(F.data.startswith("inventory:use:"))
async def inventory_use(callback: types.CallbackQuery, state: FSMContext):
    _, _, item_id, mode = callback.data.split(":")
    item_id = int(item_id)
    player = player_repo.get_player(callback.from_user.id)
    item = item_repo.get_item(item_id)

    if not item or not player:
        await callback.answer("–û—à–∏–±–∫–∞!", show_alert=True)
        return

    (
        _,
        name,
        type_,
        power,
        max_count,
        price_gold,
        price_diamonds,
        usable_in_fight,
        usable_in_profile,
    ) = item

    # –î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –ø–æ —Ä–µ–∂–∏–º—É
    if mode == "profile" and not usable_in_profile:
        await callback.answer(
            "–≠—Ç–æ—Ç –ø—Ä–µ–¥–º–µ—Ç –Ω–µ–ª—å–∑—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –ø—Ä–æ—Ñ–∏–ª–µ!", show_alert=True
        )
        return
    if mode == "battle" and not usable_in_fight:
        await callback.answer(
            "–≠—Ç–æ—Ç –ø—Ä–µ–¥–º–µ—Ç –Ω–µ–ª—å–∑—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –±–æ—é!", show_alert=True
        )
        return

    msg = ""
    # –ü—Ä–∏–º–µ–Ω—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç –ø—Ä–µ–¥–º–µ—Ç–∞
    if type_ == "potion_hp":
        # heal
        new_hp = min(player[4] + power, player[5])
        db.execute("UPDATE players SET hp=? WHERE id=?", (new_hp, player[0]))
        msg = f"üß™ –¢—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª {name}! HP –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –¥–æ {new_hp}/{player[5]}"
        if mode == "battle":
            # —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º HP –≤ –∞–∫—Ç–∏–≤–Ω–æ–π –±–∏—Ç–≤–µ
            db.execute(
                "UPDATE battles SET player_hp=? WHERE player_id=? AND status='active'",
                (new_hp, player[0]),
            )
    elif type_ == "potion_mana":
        new_mana = min(player[7] + power, player[8])
        db.execute("UPDATE players SET mana=? WHERE id=?", (new_mana, player[0]))
        msg = f"üß™ –¢—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª {name}! –ú–∞–Ω–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –¥–æ {new_mana}/{player[8]}"
    elif type_ == "bomb" and mode == "battle":
        battle = db.fetchone(
            "SELECT id, mob_id, mob_hp, player_hp FROM battles WHERE player_id=? AND status='active'",
            (player[0],),
        )
        if not battle:
            await callback.answer("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –±–æ—è!", show_alert=True)
            return
        battle_id, mob_id, mob_hp, player_hp = battle
        mob_hp = max(mob_hp - power, 0)
        db.execute("UPDATE battles SET mob_hp=? WHERE id=?", (mob_hp, battle_id))
        msg = f"üí£ –¢—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª {name}! –ú–æ–± –ø–æ–ª—É—á–∏–ª {power} —É—Ä–æ–Ω–∞.\nüíÄ HP –º–æ–±–∞: {mob_hp}"
    else:
        await callback.answer(
            "–≠—Ç–æ—Ç –ø—Ä–µ–¥–º–µ—Ç –Ω–µ –∏–º–µ–µ—Ç –±–æ–µ–≤–æ–≥–æ/–ø—Ä–æ—Ñ–∏–ª—å–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞!", show_alert=True
        )
        return

    # —É–º–µ–Ω—å—à–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–µ–¥–º–µ—Ç–∞
    db.execute(
        "UPDATE inventory SET quantity = quantity - 1 WHERE player_id=? AND item_id=?",
        (player[0], item_id),
    )
    db.execute(
        "DELETE FROM inventory WHERE player_id=? AND item_id=? AND quantity<=0",
        (player[0], item_id),
    )

    # –ü—Ä–æ—Ñ–∏–ª—å: –ø—Ä–æ—Å—Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç + –Ω–∞–∑–∞–¥
    if mode == "profile":
        await callback.message.edit_text(
            msg,
            reply_markup=types.InlineKeyboardMarkup(
                inline_keyboard=[
                    [
                        types.InlineKeyboardButton(
                            text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="inventory:profile"
                        )
                    ]
                ]
            ),
        )
        return

    # –ë–æ–π: —ç—Ç–æ —Ö–æ–¥ ‚Äî –º–æ–± –¥–æ–ª–∂–µ–Ω –æ—Ç–≤–µ—Ç–∏—Ç—å
    battle = db.fetchone(
        "SELECT id, mob_id, mob_hp, player_hp FROM battles WHERE player_id=? AND status='active'",
        (player[0],),
    )
    if not battle:
        # –µ—Å–ª–∏ –±–æ—è –Ω–µ—Ç, –ø—Ä–æ—Å—Ç–æ –ø–æ–∫–∞–∂–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        await callback.message.edit_text(
            msg,
            reply_markup=types.InlineKeyboardMarkup(
                inline_keyboard=[
                    [
                        types.InlineKeyboardButton(
                            text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu:back"
                        )
                    ]
                ]
            ),
        )
        return

    battle_id, mob_id, mob_hp, player_hp = battle
    mob = db.fetchone(
        "SELECT id, name, hp, attack, exp_reward, gold_reward, drop_item_id FROM mobs WHERE id=?",
        (mob_id,),
    )
    _, mob_name, _, mob_attack, exp_reward, gold_reward, drop_item_id = mob

    # –ï—Å–ª–∏ –º–æ–± —É–º–µ—Ä –æ—Ç –±–æ–º–±—ã ‚Äî –ø–æ–±–µ–¥–∞ –±–µ–∑ –æ—Ç–≤–µ—Ç–∞
    if mob_hp <= 0:
        # –Ω–∞–≥—Ä–∞–¥–∞, –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –±–æ—è
        player_repo.update_gold(player[0], gold_reward)
        db.execute("UPDATE battles SET status='finished' WHERE id=?", (battle_id,))
        db.execute(
            "UPDATE players SET exp = exp + ? WHERE id=?", (exp_reward, player[0])
        )
        check_level_up(player[0])
        await state.clear()
        drop_text = ""
        if drop_item_id:
            inventory_repo.add_item_to_player(player[0], drop_item_id, 1)
            item_row = db.fetchone("SELECT name FROM items WHERE id=?", (drop_item_id,))
            drop_text = (
                f"\nüéÅ –í—ã–ø–∞–ª –ø—Ä–µ–¥–º–µ—Ç: {item_row[0]}"
                if item_row
                else "\nüéÅ –í—ã–ø–∞–ª –ø—Ä–µ–¥–º–µ—Ç!"
            )

        # –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–±–µ–¥—É
        current_mana = player_repo.get_player(player[0])[7]
        max_mana = player_repo.get_player(player[0])[8]
        await callback.message.edit_text(
            msg
            + f"\nüéâ –ü–æ–±–µ–¥–∞ –Ω–∞–¥ {mob_name}!\nüìà EXP: {exp_reward}\nüí∞ Gold: {gold_reward}\nüîÆ –¢–≤–æ—è –º–∞–Ω–∞: {current_mana}/{max_mana}{drop_text}",
            reply_markup=victory_menu_inline(),
        )
        return

    # –û—Ç–≤–µ—Ç –º–æ–±–∞
    mob_dmg = random.randint(1, mob_attack)
    # —Ç–µ–∫—É—â–µ–µ HP –∏–≥—Ä–æ–∫–∞ –ø–æ—Å–ª–µ –∑–µ–ª—å—è –º–æ–≥–ª–æ –∏–∑–º–µ–Ω–∏—Ç—å—Å—è; –±–µ—Ä—ë–º –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ –∏–∑ battles
    battle = db.fetchone("SELECT player_hp FROM battles WHERE id=?", (battle_id,))
    current_player_hp = battle[0] if battle else player_hp
    current_player_hp = max(current_player_hp - mob_dmg, 0)

    # –æ–±–Ω–æ–≤–ª—è–µ–º HP –∏–≥—Ä–æ–∫–∞ –≤ players –∏ battles
    player_repo.update_hp(player[0], current_player_hp)
    db.execute(
        "UPDATE battles SET player_hp=? WHERE id=?", (current_player_hp, battle_id)
    )

    # –ü–æ—Ä–∞–∂–µ–Ω–∏–µ
    if current_player_hp <= 0:
        db.execute("UPDATE battles SET status='finished' WHERE id=?", (battle_id,))
        # –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ –ø–æ—Ä–∞–∂–µ–Ω–∏—è, —à—Ç—Ä–∞—Ñ—ã
        db.execute(
            "UPDATE players SET hp = max_hp, mana = max_mana, exp = 0 WHERE id=?",
            (player[0],),
        )
        lost_gold = int(player[10] * 0.2)
        db.execute(
            "UPDATE players SET gold = gold - ? WHERE id=?", (lost_gold, player[0])
        )

        await state.clear()
        await callback.message.edit_text(
            msg
            + f"\nüëä {mob_name} –Ω–∞–Ω—ë—Å {mob_dmg}.\nüíÄ –¢—ã –ø—Ä–æ–∏–≥—Ä–∞–ª!\n‚ù§Ô∏è HP –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –¥–æ {player[5]}.\nüí∞ –ü–æ—Ç–µ—Ä—è–Ω–æ {lost_gold} –∑–æ–ª–æ—Ç–∞.\nüìà –û–ø—ã—Ç –æ–±–Ω—É–ª—ë–Ω.",
            reply_markup=victory_menu_inline(),
        )
        return

    # –ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –±–æ—è: –ø–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    # –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –º–∞–Ω–∞/–º–∞–∫—Å –º–∞–Ω–∞
    refreshed = player_repo.get_player(player[0])
    mana, max_mana = refreshed[7], refreshed[8]

    await callback.message.edit_text(
        msg + f"\nüëä {mob_name} –æ—Ç–≤–µ—Ç–∏–ª –∏ –Ω–∞–Ω—ë—Å {mob_dmg}.\n"
        f"‚ù§Ô∏è –¢–≤–æ—ë HP: {current_player_hp}/{refreshed[5]}\n"
        f"üíÄ HP –º–æ–±–∞: {mob_hp}\n"
        f"üîÆ –¢–≤–æ—è –º–∞–Ω–∞: {mana}/{max_mana}\n"
        f"–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=fight_menu_inline(),
    )


# ---------- –ü—Ä–æ–¥–∞–∂–∞ –ø—Ä–µ–¥–º–µ—Ç–æ–≤ (—Ç–æ–ª—å–∫–æ –ø—Ä–æ—Ñ–∏–ª—å) ----------
@router.callback_query(F.data.startswith("inventory:sell:"))
async def inventory_sell(callback: types.CallbackQuery):
    item_id = int(callback.data.split(":")[2])
    player = player_repo.get_player(callback.from_user.id)
    item = item_repo.get_item(item_id)

    if not item or not player:
        await callback.answer("–û—à–∏–±–∫–∞!", show_alert=True)
        return

    (
        _,
        name,
        type_,
        power,
        max_count,
        price_gold,
        price_diamonds,
        usable_in_fight,
        usable_in_profile,
    ) = item
    sell_price = max(price_gold // 2, 1)

    player_repo.update_gold(player[0], sell_price)
    db.execute(
        "UPDATE inventory SET quantity = quantity - 1 WHERE player_id=? AND item_id=?",
        (player[0], item_id),
    )
    db.execute(
        "DELETE FROM inventory WHERE player_id=? AND item_id=? AND quantity<=0",
        (player[0], item_id),
    )

    await callback.message.answer(f"üí∞ –¢—ã –ø—Ä–æ–¥–∞–ª {name} –∑–∞ {sell_price} –∑–æ–ª–æ—Ç–∞!")

from aiogram import Router, types, F

from utils.leveling import exp_required
from utils.db import Database, PlayerRepo
from config import DB_PATH

router = Router()
db = Database(DB_PATH)
player_repo = PlayerRepo(db)


@router.callback_query(F.data == "profile:show")
async def show_profile(callback: types.CallbackQuery):
    player = player_repo.get_player(callback.from_user.id)
    if player:
        # player = (id, name, class, level, hp, max_hp, mana, max_mana, exp, gold, diamonds)
        (
            _,
            name,
            cls,
            lvl,
            hp,
            max_hp,
            max_inventory_slots,
            mana,
            max_mana,
            exp,
            gold,
            diamonds,
        ) = player

        kb = types.InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    types.InlineKeyboardButton(
                        text="üì¶ –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å", callback_data="inventory:profile"
                    )
                ],
                [types.InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu:back")],
            ]
        )

        exp_to_next = exp_required(lvl)
        await callback.message.edit_text(
            f"üë§ {name}\n‚öîÔ∏è –ö–ª–∞—Å—Å: {cls}\n‚≠ê –£—Ä–æ–≤–µ–Ω—å: {lvl}\n‚ù§Ô∏è HP: {hp}/{max_hp}\nüîÆ Mana: {mana}/{max_mana}\nüìà EXP: {exp}/{exp_to_next}\nüí∞ Gold: {gold}\nüíé Diamonds: {diamonds}",
            reply_markup=kb,
        )
    else:
        await callback.answer("–¢—ã –µ—â—ë –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω!", show_alert=True)
# handlers/quests.py

from aiogram import Router, types, F
from aiogram.utils.keyboard import InlineKeyboardBuilder
from utils.db import Database, QuestRepo, PlayerRepo, InventoryRepo
from config import DB_PATH

router = Router()
db = Database(DB_PATH)
quest_repo = QuestRepo(db)
player_repo = PlayerRepo(db)
inventory_repo = InventoryRepo(db)


@router.callback_query(F.data == "quests:menu")
async def quests_menu(callback: types.CallbackQuery):
    quests = quest_repo.list_quests()
    if not quests:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–≤–µ—Å—Ç–æ–≤!", show_alert=True)
        return

    kb = InlineKeyboardBuilder()
    text = "üéØ –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–≤–µ—Å—Ç—ã:\n"
    for (
        quest_id,
        title,
        description,
        reward_exp,
        reward_gold,
        reward_item_id,
        condition_type,
        condition_target,
        condition_amount,
    ) in quests:
        cond = f"{condition_type}:{condition_target} x{condition_amount}"
        text += f"\n{title} ‚Äî {description} (—É—Å–ª–æ–≤–∏–µ: {cond})"
        kb.button(text=f"–í–∑—è—Ç—å {title}", callback_data=f"quest:start:{quest_id}")
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu:back")
    kb.adjust(1)

    await callback.message.edit_text(text, reply_markup=kb.as_markup())


@router.callback_query(F.data.startswith("quest:start:"))
async def quest_start(callback: types.CallbackQuery):
    kb = InlineKeyboardBuilder()
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu:back")
    kb.adjust(1)
    quest_id = int(callback.data.split(":")[2])
    quest = quest_repo.get_quest(quest_id)
    player = player_repo.get_player(callback.from_user.id)
    if not quest:
        await callback.answer("–ö–≤–µ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
        return

    existing = db.fetchone(
        "SELECT status FROM player_quests WHERE player_id=? AND quest_id=?",
        (player[0], quest_id),
    )
    if existing:
        if existing[0] == "completed":
            await callback.answer("–¢—ã —É–∂–µ –≤—ã–ø–æ–ª–Ω–∏–ª —ç—Ç–æ—Ç –∫–≤–µ—Å—Ç!", show_alert=True)
            return
        elif existing[0] == "active":
            await callback.answer("–ö–≤–µ—Å—Ç —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω!", show_alert=True)
            return

    db.execute(
        "INSERT INTO player_quests (player_id, quest_id, status, progress) VALUES (?, ?, 'active', 0)",
        (player[0], quest_id),
    )

    (
        _,
        title,
        description,
        reward_exp,
        reward_gold,
        reward_item_id,
        condition_type,
        condition_target,
        condition_amount,
    ) = quest

    await callback.message.edit_text(
        f"üéØ –ö–≤–µ—Å—Ç '{title}' –≤–∑—è—Ç!\n"
        f"–û–ø–∏—Å–∞–Ω–∏–µ: {description}\n"
        f"–£—Å–ª–æ–≤–∏–µ: {condition_type} ‚Üí {condition_target} √ó{condition_amount}\n"
        f"–ù–∞–≥—Ä–∞–¥–∞: {reward_exp} EXP, {reward_gold}üí∞, {reward_item_id if reward_item_id else '‚Äî'}"
    )
from aiogram import Router, types, F
from aiogram.utils.keyboard import InlineKeyboardBuilder

from utils.db import Database, ItemRepo, InventoryRepo, PlayerRepo
from config import DB_PATH, PAYMASTER_PROVIDER_TOKEN

router = Router()
db = Database(DB_PATH)
item_repo = ItemRepo(db)
inventory_repo = InventoryRepo(db)
player_repo = PlayerRepo(db)


@router.callback_query(F.data == "shop:menu")
async def shop_menu(callback: types.CallbackQuery):
    items = item_repo.list_items()
    kb = InlineKeyboardBuilder()
    text = "üõí –ú–∞–≥–∞–∑–∏–Ω:\n"

    if items:
        for item in items:
            (
                item_id,
                name,
                type_,
                power,
                max_count,
                price_gold,
                price_diamonds,
                usable_in_fight,
                usable_in_profile,
            ) = item

            text += f"\n{name} ({type_}) ‚Äî {price_gold}üí∞ / {price_diamonds}üíé"
            kb.button(text=f"–ö—É–ø–∏—Ç—å {name}", callback_data=f"shop:buy:{item_id}")

    # –∫–Ω–æ–ø–∫–∞ –¥–æ–Ω–∞—Ç–∞
    kb.button(text="üíé –ö—É–ø–∏—Ç—å –∞–ª–º–∞–∑—ã (–¥–æ–Ω–∞—Ç)", callback_data="shop:donate")
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu:back")
    kb.adjust(1)

    await callback.message.edit_text(text, reply_markup=kb.as_markup())


@router.callback_query(F.data.startswith("shop:buy:"))
async def shop_buy(callback: types.CallbackQuery):
    item_id = int(callback.data.split(":")[2])
    player = player_repo.get_player(callback.from_user.id)
    item = item_repo.get_item(item_id)
    kb = InlineKeyboardBuilder()
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="shop:menu")
    kb.adjust(1)
    if not item or not player:
        await callback.answer("–û—à–∏–±–∫–∞!", show_alert=True)
        return

    (
        _,
        name,
        type_,
        power,
        max_count,
        price_gold,
        price_diamonds,
        usable_in_fight,
        usable_in_profile,
    ) = item

    # –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–æ–ª–æ—Ç–∞
    if price_gold > 0 and player[10] < price_gold:
        await callback.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–æ–ª–æ—Ç–∞!", show_alert=True)
        return

    # –ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–ª–º–∞–∑–æ–≤
    if price_diamonds > 0 and player[11] < price_diamonds:
        await callback.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞–ª–º–∞–∑–æ–≤!", show_alert=True)
        return

    # —Å–ø–∏—Å—ã–≤–∞–µ–º –≤–∞–ª—é—Ç—É
    if price_gold > 0:
        player_repo.update_gold(player[0], -price_gold)
    if price_diamonds > 0:
        player_repo.update_diamonds(player[0], -price_diamonds)

    # –¥–æ–±–∞–≤–ª—è–µ–º –ø—Ä–µ–¥–º–µ—Ç
    inventory_repo.add_item_to_player(player[0], item_id, 1)

    await callback.message.edit_text(
        f"‚úÖ –¢—ã –∫—É–ø–∏–ª {name} –∑–∞ {price_gold}üí∞ {price_diamonds}üíé!",
        reply_markup=kb.as_markup(),
    )


# ==========================
# –°–ò–°–¢–ï–ú–ê –î–û–ù–ê–¢–û–í PAYMASTER
# ==========================


@router.callback_query(F.data == "shop:donate")
async def shop_donate(callback: types.CallbackQuery):
    # –ü—Ä–∏–º–µ—Ä: –ø—Ä–æ–¥–∞—ë–º 100 –∞–ª–º–∞–∑–æ–≤ –∑–∞ 5$
    await callback.message.answer_invoice(
        title="üíé –ê–ª–º–∞–∑—ã",
        description="–ü–∞–∫–µ—Ç 100 –∞–ª–º–∞–∑–æ–≤",
        payload=f"diamonds:{callback.from_user.id}:100",
        provider_token=PAYMASTER_PROVIDER_TOKEN,
        currency="USD",
        prices=[types.LabeledPrice(label="100 –∞–ª–º–∞–∑–æ–≤", amount=500)],  # $5.00
    )


@router.pre_checkout_query()
async def process_pre_checkout(pre_checkout_query: types.PreCheckoutQuery):
    await pre_checkout_query.answer(ok=True)


@router.message(F.successful_payment)
async def process_successful_payment(msg: types.Message):
    payload = msg.successful_payment.invoice_payload
    if payload.startswith("diamonds:"):
        _, player_id, diamonds = payload.split(":")
        player_repo.update_diamonds(int(player_id), int(diamonds))
        await msg.answer(f"‚úÖ –û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞! –ó–∞—á–∏—Å–ª–µ–Ω–æ {diamonds}üíé")
from aiogram import Router, types, F
from aiogram.filters import Command
from aiogram.utils.keyboard import InlineKeyboardBuilder
from utils.db import Database, PlayerRepo
from config import DB_PATH

router = Router()
db = Database(DB_PATH)
player_repo = PlayerRepo(db)
kb_class = InlineKeyboardBuilder()
kb_class.button(text="‚öîÔ∏è –í–æ–∏–Ω", callback_data="class:warrior")
kb_class.button(text="üîÆ –ú–∞–≥", callback_data="class:mage")
kb_class.button(text="üó°Ô∏è –í–æ—Ä", callback_data="class:rogue")
kb_class.adjust(1)

kb_menu = InlineKeyboardBuilder()
kb_menu.button(text="‚öîÔ∏è –í –±–æ–π", callback_data="fight:start")
kb_menu.button(text="üéØ –ö–≤–µ—Å—Ç—ã", callback_data="quests:menu")
kb_menu.button(text="üõí –ú–∞–≥–∞–∑–∏–Ω", callback_data="shop:menu")
kb_menu.button(text="üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile:show")
kb_menu.adjust(2)


@router.message(Command("start"))
async def cmd_start(msg: types.Message):
    player = player_repo.get_player(msg.from_user.id)

    if player is None:
        # –ö–Ω–æ–ø–∫–∏ –≤—ã–±–æ—Ä–∞ –∫–ª–∞—Å—Å–∞
        await msg.answer("–í—ã–±–µ—Ä–∏ –∫–ª–∞—Å—Å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:", reply_markup=kb_class.as_markup())

    else:
        await msg.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=kb_menu.as_markup())


@router.callback_query(F.data.startswith("menu:back"))
async def back(callback: types.CallbackQuery):
    player = player_repo.get_player(callback.from_user.id)
    if player is None:
        # –ö–Ω–æ–ø–∫–∏ –≤—ã–±–æ—Ä–∞ –∫–ª–∞—Å—Å–∞
        await callback.message.edit_text(
            "–í—ã–±–µ—Ä–∏ –∫–ª–∞—Å—Å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:", reply_markup=kb_class.as_markup()
        )

    else:
        await callback.message.edit_text(
            "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=kb_menu.as_markup()
        )


@router.callback_query(F.data.startswith("class:"))
async def choose_class(callback: types.CallbackQuery):
    chosen_class = callback.data.split(":")[1]
    player_repo.add_player(
        player_id=callback.from_user.id,
        name=callback.from_user.first_name,
        player_class=chosen_class,
    )
    await callback.message.edit_text(
        f"üéâ –ü–µ—Ä—Å–æ–Ω–∞–∂ —Å–æ–∑–¥–∞–Ω!\n"
        f"–ö–ª–∞—Å—Å: {chosen_class.capitalize()}\n"
        f"–¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –æ—Ç–∫—Ä—ã—Ç—å üë§ –ü—Ä–æ—Ñ–∏–ª—å.",
        reply_markup=types.InlineKeyboardMarkup(
            inline_keyboard=[
                [types.InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu:back")]
            ]
        ),
    )
# states/battleblock.py
from aiogram.fsm.state import State, StatesGroup
from aiogram import Router, types, F


class BattleBlock(StatesGroup):
    active = State()


router = Router()


# –≠—Ç–æ—Ç —Ö—ç–Ω–¥–ª–µ—Ä —Å—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞ –ª—é–±–æ–π callback_query,
# –µ—Å–ª–∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ BattleBlock.active –∞–∫—Ç–∏–≤–Ω–æ
@router.callback_query(
    BattleBlock.active,
    ~(
        F.data.startswith("fight:")
        | F.data.startswith("inventory:battle")
        | F.data.startswith("inventory:use:")
    ),
)
async def block_other_callbacks(callback: types.CallbackQuery):
    await callback.answer("‚ùå –ù–µ —Å–±–µ–∂–∏—à—å!", show_alert=True)


@router.message(BattleBlock.active)
async def block_other_callbacks(message: types.Message):
    await message.answer(
        "‚ùå –ù–µ —Å–±–µ–∂–∏—à—å!",
        reply_markup=types.InlineKeyboardMarkup(
            inline_keyboard=[
                [types.InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="fight:menu")]
            ]
        ),
    )
