# config.py

# –¢–æ–∫–µ–Ω –±–æ—Ç–∞ (–ª—É—á—à–µ —Ö—Ä–∞–Ω–∏—Ç—å –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è, –Ω–æ –¥–ª—è –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ –º–æ–∂–Ω–æ –ø—Ä—è–º–æ —Ç—É—Ç)
BOT_TOKEN = "8560376370:AAER8fgeUhtGJ4zHsQEqOYrK4NA5GJml5qc"
PAYMASTER_PROVIDER_TOKEN = "2051251535:TEST:OTk5MDA4ODgxLTAwNQ"

# –ü—É—Ç—å –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
DB_PATH = "database.db"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä—ã
DEFAULT_HP = 100
DEFAULT_MANA = 50
DEFAULT_GOLD = 0
DEFAULT_DIAMONDS = 0

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ (–º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å)
LOG_LEVEL = "INFO"
import asyncio
from aiogram import Bot, Dispatcher
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from config import BOT_TOKEN
from setup import Init
from handlers import start, profile, fight, shop, quests


async def main():
    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã
    Init.setup_all()

    bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))

    dp = Dispatcher()

    # –ü–æ–¥–∫–ª—é—á–∞–µ–º —Ä–æ—É—Ç–µ—Ä—ã
    dp.include_router(start.router)
    dp.include_router(profile.router)
    dp.include_router(fight.router)
    dp.include_router(shop.router)
    dp.include_router(quests.router)

    # –ó–∞–ø—É—Å–∫
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())
import sqlite3
from config import DB_PATH, DEFAULT_HP, DEFAULT_GOLD, DEFAULT_DIAMONDS, DEFAULT_MANA


class Init:
    @staticmethod
    def create_players():
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                f"""
            CREATE TABLE IF NOT EXISTS players (
                id INTEGER PRIMARY KEY,
                name TEXT,
                class TEXT,
                level INTEGER DEFAULT 1,
                hp INTEGER DEFAULT {DEFAULT_HP},
                max_hp INTEGER DEFAULT {DEFAULT_HP},
                max_inventory_slots INTEGER DEFAULT 20,
                mana INTEGER DEFAULT {DEFAULT_MANA},
                max_mana INTEGER DEFAULT {DEFAULT_MANA},
                exp INTEGER DEFAULT 0,
                gold INTEGER DEFAULT {DEFAULT_GOLD},
                diamonds INTEGER DEFAULT {DEFAULT_DIAMONDS}
            )
            """
            )
            conn.commit()

    @staticmethod
    def create_mobs():
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute("""
            CREATE TABLE IF NOT EXISTS mobs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                hp INTEGER,
                attack INTEGER,
                exp_reward INTEGER,
                gold_reward INTEGER,
                drop_item_id INTEGER
            )
            """)
            # –î–æ–±–∞–≤–ª—è–µ–º –±–∞–∑–æ–≤—ã—Ö –º–æ–±–æ–≤, –µ—Å–ª–∏ —Ç–∞–±–ª–∏—Ü–∞ –ø—É—Å—Ç–∞—è
            cur.execute("SELECT COUNT(*) FROM mobs")
            count = cur.fetchone()[0]
            if count == 0:
                cur.executemany(
                    """
                INSERT INTO mobs (name, hp, attack, exp_reward, gold_reward, drop_item_id)
                VALUES (?, ?, ?, ?, ?, ?)
                """,
                    [
                        ("–°–ª–∏–∑–µ–Ω—å", 30, 5, 10, 5, None),
                        ("–ì–æ–±–ª–∏–Ω", 50, 10, 20, 10, None),
                        ("–û—Ä–∫", 80, 15, 30, 20, None),
                        ("–î—Ä–∞–∫–æ–Ω—á–∏–∫", 120, 20, 50, 50, None),
                    ],
                )
            conn.commit()

    @staticmethod
    def create_items():
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute("""
            CREATE TABLE IF NOT EXISTS items (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                type TEXT,
                power INTEGER,
                max_count INTEGER DEFAULT 9,
                price_gold INTEGER,
                price_diamonds INTEGER
            )
            """)
            conn.commit()

    @staticmethod
    def create_inventory():
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute("""
            CREATE TABLE IF NOT EXISTS inventory (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                player_id INTEGER,
                item_id INTEGER,
                quantity INTEGER DEFAULT 1
            )
            """)
            conn.commit()

    @staticmethod
    def create_quests():
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute("""
                            
                CREATE TABLE IF NOT EXISTS quests (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT NOT NULL,
                    description TEXT,
                    reward_exp INTEGER,
                    reward_gold INTEGER,
                    reward_item_id INTEGER,
                    condition_type TEXT NOT NULL,       -- —Ç–∏–ø —É—Å–ª–æ–≤–∏—è: kill_mob, collect_item, reach_level
                    condition_target INTEGER NOT NULL,  -- ID –º–æ–±–∞, –ø—Ä–µ–¥–º–µ—Ç–∞ –∏–ª–∏ —É—Ä–æ–≤–µ–Ω—å
                    condition_amount INTEGER DEFAULT 1   -- —Å–∫–æ–ª—å–∫–æ –Ω—É–∂–Ω–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä: —É–±–∏—Ç—å 3 –º–æ–±–∞, —Å–æ–±—Ä–∞—Ç—å 5 –ø—Ä–µ–¥–º–µ—Ç–æ–≤)
                )

            """)
            conn.commit()
            cur.execute("SELECT COUNT(*) FROM quests")
            count = cur.fetchone()[0]

            if count == 0:
                cur.executemany(
                    """
                    INSERT INTO quests (title, description, reward_exp, reward_gold, reward_item_id, condition_type, condition_target, condition_amount)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                    """,
                    [
                        (
                            "–ü–µ—Ä–≤—ã–π —à–∞–≥",
                            "–£–±–µ–π –ª—é–±–æ–≥–æ –º–æ–±–∞",
                            10,
                            5,
                            None,
                            "kill_mob",
                            0,
                            1,
                        ),
                        (
                            "–û—Ö–æ—Ç–∞ –Ω–∞ –≥–æ–±–ª–∏–Ω–∞",
                            "–ü–æ–±–µ–¥–∏ –≥–æ–±–ª–∏–Ω–∞",
                            20,
                            10,
                            None,
                            "kill_mob",
                            2,
                            1,
                        ),
                        (
                            "–°–∏–ª–∞ –æ—Ä–∫–∞",
                            "–°—Ä–∞–∑–∏—Å—å —Å –æ—Ä–∫–æ–º",
                            30,
                            20,
                            None,
                            "kill_mob",
                            3,
                            1,
                        ),
                        (
                            "–î—Ä–∞–∫–æ–Ω—å—è —É–≥—Ä–æ–∑–∞",
                            "–ü–æ–±–µ–¥–∏ –¥—Ä–∞–∫–æ–Ω—á–∏–∫–∞",
                            50,
                            50,
                            None,
                            "kill_mob",
                            4,
                            1,
                        ),
                    ],
                )

            conn.commit()

    @staticmethod
    def create_battles():
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute("""
            CREATE TABLE IF NOT EXISTS battles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                player_id INTEGER,
                mob_id INTEGER,
                mob_hp INTEGER,
                player_hp INTEGER,
                status TEXT DEFAULT 'active'
            )
            """)
            conn.commit()

    @staticmethod
    def create_player_quests():
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute("""
            CREATE TABLE IF NOT EXISTS player_quests (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                player_id INTEGER,
                quest_id INTEGER,
                status TEXT DEFAULT 'active'
            )
            """)
            conn.commit()

    @staticmethod
    def setup_all():
        Init.create_players()
        Init.create_mobs()
        Init.create_items()
        Init.create_inventory()
        Init.create_quests()
        Init.create_battles()
        Init.create_player_quests()
        print("‚úÖ –í—Å–µ —Ç–∞–±–ª–∏—Ü—ã —Å–æ–∑–¥–∞–Ω—ã/–ø—Ä–æ–≤–µ—Ä–µ–Ω—ã!")


if __name__ == "__main__":
    Init.setup_all()
import sqlite3
from typing import Optional, List, Tuple
from config import DB_PATH, DEFAULT_HP, DEFAULT_MANA, DEFAULT_DIAMONDS, DEFAULT_GOLD


class Database:
    def __init__(self, path: str = DB_PATH):
        self.conn = sqlite3.connect(path)
        self.cur = self.conn.cursor()

    def execute(self, query: str, params: Tuple = ()):
        self.cur.execute(query, params)
        self.conn.commit()

    def fetchone(self, query: str, params: Tuple = ()):
        self.cur.execute(query, params)
        return self.cur.fetchone()

    def fetchall(self, query: str, params: Tuple = ()):
        self.cur.execute(query, params)
        return self.cur.fetchall()


# ------------------ Players ------------------
class PlayerRepo:
    def __init__(self, db: Database):
        self.db = db

    def add_player(self, player_id: int, name: str, player_class: str):
        self.db.execute(
            """INSERT INTO players 
            (id, name, class, level, hp, max_hp, mana, max_mana, exp, gold, diamonds, max_inventory_slots)
            VALUES (?, ?, ?, 1, ?, ?, ?, ?, 0, ?, ?, 20)""",
            (
                player_id,
                name,
                player_class,
                DEFAULT_HP,
                DEFAULT_HP,
                DEFAULT_MANA,
                DEFAULT_MANA,
                DEFAULT_GOLD,
                DEFAULT_DIAMONDS,
            ),
        )

    def get_player(self, player_id: int) -> Optional[Tuple]:
        return self.db.fetchone("SELECT * FROM players WHERE id=?", (player_id,))

    def update_hp(self, player_id: int, new_hp: int):
        self.db.execute("UPDATE players SET hp=? WHERE id=?", (new_hp, player_id))

    def update_gold(self, player_id: int, amount: int):
        self.db.execute(
            "UPDATE players SET gold = gold + ? WHERE id=?", (amount, player_id)
        )

    def update_diamonds(self, player_id: int, amount: int):
        self.db.execute(
            "UPDATE players SET diamonds = diamonds + ? WHERE id=?", (amount, player_id)
        )


# ------------------ Mobs ------------------
class MobRepo:
    def __init__(self, db: Database):
        self.db = db

    def list_mobs(self) -> List[Tuple]:
        return self.db.fetchall("SELECT * FROM mobs")

    def get_mob(self, mob_id: int) -> Optional[Tuple]:
        return self.db.fetchone("SELECT * FROM mobs WHERE id=?", (mob_id,))


# ------------------ Items ------------------
class ItemRepo:
    def __init__(self, db: Database):
        self.db = db

    def list_items(self) -> List[Tuple]:
        return self.db.fetchall("SELECT * FROM items")

    def get_item(self, item_id: int) -> Optional[Tuple]:
        return self.db.fetchone("SELECT * FROM items WHERE id=?", (item_id,))


# ------------------ Inventory ------------------
class InventoryRepo:
    def __init__(self, db: Database):
        self.db = db

    def add_item_to_player(self, player_id: int, item_id: int, quantity: int = 1):
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø—Ä–µ–¥–º–µ—Ç —É –∏–≥—Ä–æ–∫–∞
        existing = self.db.fetchone(
            "SELECT id, quantity FROM inventory WHERE player_id=? AND item_id=?",
            (player_id, item_id),
        )

        # –£–∑–Ω–∞—ë–º max_count –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞
        item = self.db.fetchone("SELECT max_count FROM items WHERE id=?", (item_id,))
        max_count = item[0] if item else 9

        if existing:
            inv_id, current_qty = existing
            new_qty = min(current_qty + quantity, max_count)
            self.db.execute(
                "UPDATE inventory SET quantity=? WHERE id=?", (new_qty, inv_id)
            )
        else:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ—Ç–æ–≤ —É –∏–≥—Ä–æ–∫–∞
            slots = self.db.fetchone(
                "SELECT COUNT(*) FROM inventory WHERE player_id=?", (player_id,)
            )[0]

            max_slots = self.db.fetchone(
                "SELECT max_inventory_slots FROM players WHERE id=?", (player_id,)
            )[0]

            if slots < max_slots:
                self.db.execute(
                    "INSERT INTO inventory (player_id, item_id, quantity) VALUES (?, ?, ?)",
                    (player_id, item_id, min(quantity, max_count)),
                )
            else:
                raise Exception("–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –∑–∞–ø–æ–ª–Ω–µ–Ω!")

    def get_inventory(self, player_id: int) -> List[Tuple]:
        return self.db.fetchall(
            "SELECT * FROM inventory WHERE player_id=?", (player_id,)
        )


# ------------------ Quests ------------------
class QuestRepo:
    def __init__(self, db: Database):
        self.db = db

    def list_quests(self) -> List[Tuple]:
        return self.db.fetchall("SELECT * FROM quests")

    def get_quest(self, quest_id: int) -> Optional[Tuple]:
        return self.db.fetchone("SELECT * FROM quests WHERE id=?", (quest_id,))
import random
from aiogram import Router, types, F
from aiogram.utils.keyboard import InlineKeyboardBuilder
from utils.quests_logic import check_quests

from utils.db import Database, PlayerRepo, MobRepo
from config import DB_PATH

router = Router()
db = Database(DB_PATH)
player_repo = PlayerRepo(db)
mob_repo = MobRepo(db)


def fight_menu():
    kb = InlineKeyboardBuilder()
    kb.button(text="‚öîÔ∏è –ê—Ç–∞–∫–∞", callback_data="fight:attack")
    kb.button(text="üõ°Ô∏è –ó–∞—â–∏—Ç–∞", callback_data="fight:defend")
    kb.button(text="üîÆ –ú–∞–≥–∏—è", callback_data="fight:magic")
    kb.adjust(2)
    return kb.as_markup()


async def fight_defeat(callback, player, battle_id, name, mob_dmg, text):
    db.execute("UPDATE battles SET status='finished' WHERE id=?", (battle_id,))

    db.execute("UPDATE players SET hp = max_hp WHERE id=?", (player[0],))

    db.execute("UPDATE players SET mana = max_mana WHERE id=?", (player[0],))

    lost_gold = int(player[10] * 0.2)  # player[10] = gold
    db.execute("UPDATE players SET gold = gold - ? WHERE id=?", (lost_gold, player[0]))

    db.execute("UPDATE players SET exp = 0 WHERE id=?", (player[0],))

    await callback.message.edit_text(
        text + f"üëä {name} –Ω–∞–Ω—ë—Å {mob_dmg}.\nüíÄ –¢—ã –ø—Ä–æ–∏–≥—Ä–∞–ª!\n"
        f"‚ù§Ô∏è HP –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –¥–æ {player[5]}.\n"
        f"üí∞ –ü–æ—Ç–µ—Ä—è–Ω–æ {lost_gold} –∑–æ–ª–æ—Ç–∞.\n"
        f"üìà –û–ø—ã—Ç –æ–±–Ω—É–ª—ë–Ω."
    )


@router.callback_query(F.data == "fight:start")
async def start_fight(callback: types.CallbackQuery):
    player = player_repo.get_player(callback.from_user.id)
    if not player:
        await callback.answer("–°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Å—è!", show_alert=True)
        return

    # –ó–∞–≤–µ—Ä—à–∞–µ–º —Å—Ç–∞—Ä—ã–π –±–æ–π, –µ—Å–ª–∏ –æ–Ω –µ—â—ë –∞–∫—Ç–∏–≤–µ–Ω
    db.execute(
        "UPDATE battles SET status='finished' WHERE player_id=? AND status='active'",
        (player[0],),
    )

    mobs = mob_repo.list_mobs()
    if not mobs:
        await callback.answer("–ù–µ—Ç –º–æ–±–æ–≤ –≤ –±–∞–∑–µ!", show_alert=True)
        return

    mob = random.choice(mobs)
    mob_id = mob[0]  # id –º–æ–±–∞
    name = mob[1]  # –∏–º—è
    hp = mob[2]  # –∑–¥–æ—Ä–æ–≤—å–µ
    attack = mob[3]  # —Å–∏–ª–∞ –∞—Ç–∞–∫–∏
    exp_reward = mob[4]  # –æ–ø—ã—Ç
    gold_reward = mob[5]  # –∑–æ–ª–æ—Ç–æ
    drop_item_id = mob[6]  # –ø—Ä–µ–¥–º–µ—Ç

    # —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å –±–æ—è
    db.execute(
        "INSERT INTO battles (player_id, mob_id, mob_hp, player_hp, status) VALUES (?, ?, ?, ?, 'active')",
        (player[0], mob_id, hp, player[4]),
    )

    await callback.message.edit_text(
        f"‚öîÔ∏è –¢—ã –≤—Å—Ç—Ä–µ—Ç–∏–ª {name}!\n‚ù§Ô∏è HP –º–æ–±–∞: {hp}\n–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=fight_menu(),
    )


@router.callback_query(F.data == "fight:attack")
async def player_attack(callback: types.CallbackQuery):
    player = player_repo.get_player(callback.from_user.id)
    battle = db.fetchone(
        "SELECT id, mob_id, mob_hp, player_hp FROM battles WHERE player_id=? AND status='active'",
        (player[0],),
    )
    if not battle:
        await callback.answer("–ë–æ–π –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
        return

    battle_id, mob_id, mob_hp, player_hp = battle
    mob = mob_repo.get_mob(mob_id)
    name = mob[1]
    attack = mob[3]
    exp_reward = mob[4]
    gold_reward = mob[5]

    # –ò–≥—Ä–æ–∫ –Ω–∞–Ω–æ—Å–∏—Ç —É—Ä–æ–Ω
    dmg = random.randint(5, 15)
    mob_hp = max(mob_hp - dmg, 0)

    text = f"‚öîÔ∏è –¢—ã —É–¥–∞—Ä–∏–ª {name} –Ω–∞ {dmg}!\n"

    if mob_hp <= 0:
        # –ü–æ–±–µ–¥–∞
        player_repo.update_gold(player[0], gold_reward)
        db.execute("UPDATE battles SET status='finished' WHERE id=?", (battle_id,))
        db.execute(
            "UPDATE players SET exp = exp + ? WHERE id=?", (exp_reward, player[0])
        )

        drop_text = ""
        if drop_item_id:
            # –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–µ–¥–º–µ—Ç –∏–≥—Ä–æ–∫—É
            inventory_repo.add_item_to_player(player[0], drop_item_id, 1)
            item = db.fetchone("SELECT name FROM items WHERE id=?", (drop_item_id,))
            drop_text = (
                f"\nüéÅ –í—ã–ø–∞–ª –ø—Ä–µ–¥–º–µ—Ç: {item[0]}" if item else "\nüéÅ –í—ã–ø–∞–ª –ø—Ä–µ–¥–º–µ—Ç!"
            )

        await callback.message.edit_text(
            text + f"üéâ –ü–æ–±–µ–¥–∞ –Ω–∞–¥ {name}!\n"
            f"üìà EXP: {exp_reward}\n"
            f"üí∞ Gold: {gold_reward}"
            f"{drop_text}"
        )

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–≤–µ—Å—Ç–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä kill_mob)
        messages = check_quests(player[0], "kill_mob", mob_id, 1)
        for msg in messages:
            await callback.message.answer(msg)

    return
    # –ú–æ–± –æ—Ç–≤–µ—á–∞–µ—Ç
    mob_dmg = random.randint(1, attack)
    player_hp = max(player_hp - mob_dmg, 0)
    player_repo.update_hp(player[0], player_hp)

    if player_hp <= 0:
        await fight_defeat(callback, player, battle_id, name, mob_dmg, text)
    else:
        db.execute(
            "UPDATE battles SET mob_hp=?, player_hp=? WHERE id=?",
            (mob_hp, player_hp, battle_id),
        )
        await callback.message.edit_text(
            text + f"üëä {name} –æ—Ç–≤–µ—Ç–∏–ª –∏ –Ω–∞–Ω—ë—Å {mob_dmg}.\n"
            f"‚ù§Ô∏è –¢–≤–æ—ë HP: {player_hp}/{player[5]}\n"
            f"üíÄ HP –º–æ–±–∞: {mob_hp}\n"
            f"–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=fight_menu(),
        )


@router.callback_query(F.data == "fight:defend")
async def player_defend(callback: types.CallbackQuery):
    player = player_repo.get_player(callback.from_user.id)
    battle = db.fetchone(
        "SELECT id, mob_id, mob_hp, player_hp FROM battles WHERE player_id=? AND status='active'",
        (player[0],),
    )
    if not battle:
        await callback.answer("–ë–æ–π –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
        return

    battle_id, mob_id, mob_hp, player_hp = battle
    mob = mob_repo.get_mob(mob_id)
    name = mob[1]
    attack = mob[3]
    exp_reward = mob[4]
    gold_reward = mob[5]

    # –ò–≥—Ä–æ–∫ –Ω–∞–Ω–æ—Å–∏—Ç –Ω–µ–±–æ–ª—å—à–æ–π —É—Ä–æ–Ω –ø—Ä–∏ –∑–∞—â–∏—Ç–µ
    dmg = random.randint(3, 8)
    mob_hp = max(mob_hp - dmg, 0)

    # –ú–æ–± –Ω–∞–Ω–æ—Å–∏—Ç —É–º–µ–Ω—å—à–µ–Ω–Ω—ã–π —É—Ä–æ–Ω
    mob_dmg = max(random.randint(1, attack) // 2, 0)
    player_hp = max(player_hp - mob_dmg, 0)
    player_repo.update_hp(player[0], player_hp)

    text = f"üõ°Ô∏è –¢—ã –∑–∞—â–∏—â–∞–µ—à—å—Å—è –∏ –Ω–∞–Ω–æ—Å–∏—à—å {dmg} —É—Ä–æ–Ω–∞ {name}!\n"

    if mob_hp <= 0:
        player_repo.update_gold(player[0], gold_reward)
        db.execute("UPDATE battles SET status='finished' WHERE id=?", (battle_id,))
        await callback.message.edit_text(
            text + f"üéâ –ü–æ–±–µ–¥–∞ –Ω–∞–¥ {name}!\n"
            f"üìà EXP: {exp_reward}\n"
            f"üí∞ Gold: {gold_reward}"
        )
        return

    if player_hp <= 0:
        await fight_defeat(callback, player, battle_id, name, mob_dmg, text)

    else:
        db.execute(
            "UPDATE battles SET mob_hp=?, player_hp=? WHERE id=?",
            (mob_hp, player_hp, battle_id),
        )
        await callback.message.edit_text(
            text + f"üëä {name} –∞—Ç–∞–∫—É–µ—Ç, –Ω–æ —Ç–≤–æ—è –∑–∞—â–∏—Ç–∞ —Å–Ω–∏–∂–∞–µ—Ç —É—Ä–æ–Ω!\n"
            f"‚ù§Ô∏è –¢–≤–æ—ë HP: {player_hp}/{player[5]}\n"
            f"üíÄ HP –º–æ–±–∞: {mob_hp}\n"
            f"–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=fight_menu(),
        )


@router.callback_query(F.data == "fight:magic")
async def player_magic(callback: types.CallbackQuery):
    player = player_repo.get_player(callback.from_user.id)
    if not player:
        await callback.answer("–°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Å—è!", show_alert=True)
        return

    # –ò—â–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π –±–æ–π
    battle = db.fetchone(
        "SELECT id, mob_id, mob_hp, player_hp FROM battles WHERE player_id=? AND status='active'",
        (player[0],),
    )
    if not battle:
        await callback.answer("–ë–æ–π –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
        return

    battle_id, mob_id, mob_hp, player_hp = battle

    # –ü–æ–ª—É—á–∞–µ–º –º–æ–±–∞ –∏–∑ –ë–î
    mob = mob_repo.get_mob(mob_id)
    if not mob:
        await callback.answer("–ú–æ–± –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
        return

    name = mob[1]
    attack = mob[3]
    exp_reward = mob[4]
    gold_reward = mob[5]

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∞–Ω—É (player[6] = mana, player[7] = max_mana)
    if player[6] < 10:
        await callback.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã (–Ω—É–∂–Ω–æ 10)!", show_alert=True)
        return

    # –ú–∞–≥–∏—è: –≤—ã—Å–æ–∫–∏–π —É—Ä–æ–Ω, —Ä–∞—Å—Ö–æ–¥ –º–∞–Ω—ã
    dmg = random.randint(15, 30)
    mob_hp = max(mob_hp - dmg, 0)

    # –°–ø–∏—Å—ã–≤–∞–µ–º 10 –º–∞–Ω—ã
    new_mana = max(player[6] - 10, 0)
    db.execute("UPDATE players SET mana=? WHERE id=?", (new_mana, player[0]))

    text = f"üîÆ –¢—ã –∏—Å–ø–æ–ª—å–∑—É–µ—à—å –º–∞–≥–∏—é –∏ –Ω–∞–Ω–æ—Å–∏—à—å {dmg} —É—Ä–æ–Ω–∞ {name}!\n"

    # –ï—Å–ª–∏ –º–æ–± –ø–æ–≥–∏–± ‚Äî –ø–æ–±–µ–¥–∞
    if mob_hp <= 0:
        player_repo.update_gold(player[0], gold_reward)
        db.execute("UPDATE battles SET status='finished' WHERE id=?", (battle_id,))
        await callback.message.edit_text(
            text + f"üéâ –ü–æ–±–µ–¥–∞ –Ω–∞–¥ {name}!\n"
            f"üìà EXP: {exp_reward}\n"
            f"üí∞ Gold: {gold_reward}\n"
            f"üîÆ –¢–≤–æ—è –º–∞–Ω–∞: {new_mana}/{player[7]}"
        )
        return

    # –ò–Ω–∞—á–µ –º–æ–± –æ—Ç–≤–µ—á–∞–µ—Ç
    mob_dmg = random.randint(1, attack)
    player_hp = max(player_hp - mob_dmg, 0)
    player_repo.update_hp(player[0], player_hp)

    if player_hp <= 0:
        await fight_defeat(callback, player, battle_id, name, mob_dmg, text)
    else:
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±–æ—è –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é
        db.execute(
            "UPDATE battles SET mob_hp=?, player_hp=? WHERE id=?",
            (mob_hp, player_hp, battle_id),
        )
        await callback.message.edit_text(
            text + f"üëä {name} –æ—Ç–≤–µ—Ç–∏–ª –∏ –Ω–∞–Ω—ë—Å {mob_dmg}.\n"
            f"‚ù§Ô∏è –¢–≤–æ—ë HP: {player_hp}/{player[5]}\n"
            f"üíÄ HP –º–æ–±–∞: {mob_hp}\n"
            f"üîÆ –¢–≤–æ—è –º–∞–Ω–∞: {new_mana}/{player[7]}\n"
            f"–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=fight_menu(),
        )
from aiogram import Router, types, F

from utils.db import Database, PlayerRepo
from config import DB_PATH

router = Router()
db = Database(DB_PATH)
player_repo = PlayerRepo(db)


@router.callback_query(F.data == "profile:show")
async def show_profile(callback: types.CallbackQuery):
    player = player_repo.get_player(callback.from_user.id)
    if player:
        # player = (id, name, class, level, hp, max_hp, mana, max_mana, exp, gold, diamonds)
        (
            _,
            name,
            cls,
            lvl,
            hp,
            max_hp,
            max_inventory_slots,
            mana,
            max_mana,
            exp,
            gold,
            diamonds,
        ) = player

        kb = types.InlineKeyboardMarkup(
            inline_keyboard=[
                [types.InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu:back")]
            ]
        )

        await callback.message.edit_text(
            f"üë§ {name}\n‚öîÔ∏è –ö–ª–∞—Å—Å: {cls}\n‚≠ê –£—Ä–æ–≤–µ–Ω—å: {lvl}\n‚ù§Ô∏è HP: {hp}/{max_hp}\nüîÆ Mana: {mana}/{max_mana}\nüìà EXP: {exp}\nüí∞ Gold: {gold}\nüíé Diamonds: {diamonds}",
            reply_markup=kb,
        )
    else:
        await callback.answer("–¢—ã –µ—â—ë –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω!", show_alert=True)
from aiogram import Router, types, F
from aiogram.utils.keyboard import InlineKeyboardBuilder

from utils.db import Database, QuestRepo, PlayerRepo, InventoryRepo
from config import DB_PATH

router = Router()
db = Database(DB_PATH)
quest_repo = QuestRepo(db)
player_repo = PlayerRepo(db)
inventory_repo = InventoryRepo(db)


@router.callback_query(F.data == "quests:menu")
async def quests_menu(callback: types.CallbackQuery):
    quests = quest_repo.list_quests()
    if not quests:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–≤–µ—Å—Ç–æ–≤!", show_alert=True)
        return

    kb = InlineKeyboardBuilder()
    text = "üéØ –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–≤–µ—Å—Ç—ã:\n"
    for (
        quest_id,
        title,
        description,
        reward_exp,
        reward_gold,
        reward_item_id,
        condition_type,
        condition_target,
        condition_amount,
    ) in quests:
        text += f"\n{title} ‚Äî {description}"
        kb.button(text=f"–í–∑—è—Ç—å {title}", callback_data=f"quest:start:{quest_id}")
    kb.adjust(1)

    await callback.message.edit_text(text, reply_markup=kb.as_markup())


@router.callback_query(F.data.startswith("quest:start:"))
async def quest_start(callback: types.CallbackQuery):
    quest_id = int(callback.data.split(":")[2])
    quest = quest_repo.get_quest(quest_id)
    player = player_repo.get_player(callback.from_user.id)

    if not quest:
        await callback.answer("–ö–≤–µ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
        return

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∑–∞–ø–∏—Å—å –≤ player_quests
    existing = db.fetchone(
        "SELECT status FROM player_quests WHERE player_id=? AND quest_id=?",
        (player[0], quest_id),
    )

    if existing:
        if existing[0] == "completed":
            await callback.answer("–¢—ã —É–∂–µ –≤—ã–ø–æ–ª–Ω–∏–ª —ç—Ç–æ—Ç –∫–≤–µ—Å—Ç!", show_alert=True)
            return
        elif existing[0] == "active":
            await callback.answer("–ö–≤–µ—Å—Ç —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω!", show_alert=True)
            return

    # –°–æ–∑–¥–∞—ë–º –∑–∞–ø–∏—Å—å –æ –∫–≤–µ—Å—Ç–µ
    db.execute(
        "INSERT INTO player_quests (player_id, quest_id, status) VALUES (?, ?, 'active')",
        (player[0], quest_id),
    )

    (
        _,
        title,
        description,
        reward_exp,
        reward_gold,
        reward_item_id,
        condition_type,
        condition_target,
        condition_amount,
    ) = quest

    await callback.message.edit_text(
        f"üéØ –ö–≤–µ—Å—Ç '{title}' –≤–∑—è—Ç!\n"
        f"–û–ø–∏—Å–∞–Ω–∏–µ: {description}\n"
        f"–ù–∞–≥—Ä–∞–¥–∞: {reward_exp} EXP, {reward_gold}üí∞, "
        f"{reward_item_id if reward_item_id else '‚Äî'}"
    )


@router.callback_query(F.data.startswith("quest:complete:"))
async def quest_complete(callback: types.CallbackQuery):
    quest_id = int(callback.data.split(":")[2])
    quest = quest_repo.get_quest(quest_id)
    player = player_repo.get_player(callback.from_user.id)

    if not quest:
        await callback.answer("–ö–≤–µ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
        return

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å
    existing = db.fetchone(
        "SELECT status FROM player_quests WHERE player_id=? AND quest_id=?",
        (player[0], quest_id),
    )

    if not existing or existing[0] != "active":
        await callback.answer("–ö–≤–µ—Å—Ç –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω!", show_alert=True)
        return

    # –ú–µ–Ω—è–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞ completed
    db.execute(
        "UPDATE player_quests SET status='completed' WHERE player_id=? AND quest_id=?",
        (player[0], quest_id),
    )

    _, title, description, reward_exp, reward_gold, reward_item_id = quest

    # –í—ã–¥–∞—ë–º –Ω–∞–≥—Ä–∞–¥—É
    player_repo.update_gold(player[0], reward_gold)
    db.execute("UPDATE players SET exp = exp + ? WHERE id=?", (reward_exp, player[0]))
    if reward_item_id:
        inventory_repo.add_item_to_player(player[0], reward_item_id, 1)

    await callback.message.edit_text(
        f"üéâ –ö–≤–µ—Å—Ç '{title}' –≤—ã–ø–æ–ª–Ω–µ–Ω!\n"
        f"üìà EXP: {reward_exp}\n"
        f"üí∞ Gold: {reward_gold}\n"
        f"üéÅ –ü—Ä–µ–¥–º–µ—Ç: {reward_item_id if reward_item_id else '‚Äî'}"
    )

from aiogram import Router, types, F
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.filters import Command

from utils.db import Database, ItemRepo, InventoryRepo, PlayerRepo
from config import DB_PATH, PAYMASTER_PROVIDER_TOKEN

router = Router()
db = Database(DB_PATH)
item_repo = ItemRepo(db)
inventory_repo = InventoryRepo(db)
player_repo = PlayerRepo(db)


@router.callback_query(F.data == "shop:menu")
async def shop_menu(callback: types.CallbackQuery):
    items = item_repo.list_items()
    kb = InlineKeyboardBuilder()
    text = "üõí –ú–∞–≥–∞–∑–∏–Ω:\n"

    if items:
        for item_id, name, type_, power, max_count, price_gold, price_diamonds in items:
            text += f"\n{name} ({type_}) ‚Äî {price_gold}üí∞ / {price_diamonds}üíé"
            kb.button(text=f"–ö—É–ø–∏—Ç—å {name}", callback_data=f"shop:buy:{item_id}")

    # –∫–Ω–æ–ø–∫–∞ –¥–æ–Ω–∞—Ç–∞
    kb.button(text="üíé –ö—É–ø–∏—Ç—å –∞–ª–º–∞–∑—ã (–¥–æ–Ω–∞—Ç)", callback_data="shop:donate")
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu:back")
    kb.adjust(1)

    await callback.message.edit_text(text, reply_markup=kb.as_markup())


@router.callback_query(F.data.startswith("shop:buy:"))
async def shop_buy(callback: types.CallbackQuery):
    item_id = int(callback.data.split(":")[2])
    player = player_repo.get_player(callback.from_user.id)
    item = item_repo.get_item(item_id)

    if not item:
        await callback.answer("–¢–∞–∫–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç–∞ –Ω–µ—Ç!", show_alert=True)
        return

    _, name, type_, power, max_count, price_gold, price_diamonds = item

    if player[10] < price_gold:  # gold
        await callback.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–æ–ª–æ—Ç–∞!", show_alert=True)
        return

    # —Å–ø–∏—Å—ã–≤–∞–µ–º –∑–æ–ª–æ—Ç–æ
    player_repo.update_gold(player[0], -price_gold)
    # –¥–æ–±–∞–≤–ª—è–µ–º –ø—Ä–µ–¥–º–µ—Ç
    inventory_repo.add_item_to_player(player[0], item_id, 1)

    await callback.message.edit_text(f"‚úÖ –¢—ã –∫—É–ø–∏–ª {name} –∑–∞ {price_gold}üí∞!")


# ==========================
# –°–ò–°–¢–ï–ú–ê –î–û–ù–ê–¢–û–í PAYMASTER
# ==========================


@router.callback_query(F.data == "shop:donate")
async def shop_donate(callback: types.CallbackQuery):
    # –ü—Ä–∏–º–µ—Ä: –ø—Ä–æ–¥–∞—ë–º 100 –∞–ª–º–∞–∑–æ–≤ –∑–∞ 5$
    await callback.message.answer_invoice(
        title="üíé –ê–ª–º–∞–∑—ã",
        description="–ü–∞–∫–µ—Ç 100 –∞–ª–º–∞–∑–æ–≤",
        payload=f"diamonds:{callback.from_user.id}:100",  # payload –¥–ª—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
        provider_token=PAYMASTER_PROVIDER_TOKEN,
        currency="USD",
        prices=[types.LabeledPrice(label="100 –∞–ª–º–∞–∑–æ–≤", amount=500)],  # 500 = $5.00
    )


@router.pre_checkout_query()
async def process_pre_checkout(pre_checkout_query: types.PreCheckoutQuery):
    # –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –æ–ø–ª–∞—Ç—É
    await pre_checkout_query.answer(ok=True)


@router.message(F.successful_payment)
async def process_successful_payment(msg: types.Message):
    payload = msg.successful_payment.invoice_payload
    if payload.startswith("diamonds:"):
        _, player_id, diamonds = payload.split(":")
        player_repo.update_diamonds(int(player_id), int(diamonds))
        await msg.answer(f"‚úÖ –û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞! –ó–∞—á–∏—Å–ª–µ–Ω–æ {diamonds}üíé")
from aiogram import Router, types, F
from aiogram.filters import Command
from aiogram.utils.keyboard import InlineKeyboardBuilder
from utils.db import Database, PlayerRepo
from config import DB_PATH

router = Router()
db = Database(DB_PATH)
player_repo = PlayerRepo(db)
kb_class = InlineKeyboardBuilder()
kb_class.button(text="‚öîÔ∏è –í–æ–∏–Ω", callback_data="class:warrior")
kb_class.button(text="üîÆ –ú–∞–≥", callback_data="class:mage")
kb_class.button(text="üó°Ô∏è –í–æ—Ä", callback_data="class:rogue")
kb_class.adjust(1)

kb_menu = InlineKeyboardBuilder()
kb_menu.button(text="‚öîÔ∏è –í –±–æ–π", callback_data="fight:start")
kb_menu.button(text="üéØ –ö–≤–µ—Å—Ç—ã", callback_data="quests:menu")
kb_menu.button(text="üõí –ú–∞–≥–∞–∑–∏–Ω", callback_data="shop:menu")
kb_menu.button(text="üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile:show")
kb_menu.adjust(2)


@router.message(Command("start"))
async def cmd_start(msg: types.Message):
    player = player_repo.get_player(msg.from_user.id)

    if player is None:
        # –ö–Ω–æ–ø–∫–∏ –≤—ã–±–æ—Ä–∞ –∫–ª–∞—Å—Å–∞
        await msg.answer("–í—ã–±–µ—Ä–∏ –∫–ª–∞—Å—Å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:", reply_markup=kb_class.as_markup())

    else:
        await msg.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=kb_menu.as_markup())


@router.callback_query(F.data.startswith("menu:back"))
async def back(callback: types.CallbackQuery):
    player = player_repo.get_player(callback.from_user.id)
    if player is None:
        # –ö–Ω–æ–ø–∫–∏ –≤—ã–±–æ—Ä–∞ –∫–ª–∞—Å—Å–∞
        await callback.message.edit_text(
            "–í—ã–±–µ—Ä–∏ –∫–ª–∞—Å—Å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:", reply_markup=kb_class.as_markup()
        )

    else:
        await callback.message.edit_text(
            "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=kb_menu.as_markup()
        )


@router.callback_query(F.data.startswith("class:"))
async def choose_class(callback: types.CallbackQuery):
    chosen_class = callback.data.split(":")[1]
    player_repo.add_player(
        player_id=callback.from_user.id,
        name=callback.from_user.first_name,
        player_class=chosen_class,
    )
    await callback.message.edit_text(
        f"üéâ –ü–µ—Ä—Å–æ–Ω–∞–∂ —Å–æ–∑–¥–∞–Ω!\n"
        f"–ö–ª–∞—Å—Å: {chosen_class.capitalize()}\n"
        f"–¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –æ—Ç–∫—Ä—ã—Ç—å üë§ –ü—Ä–æ—Ñ–∏–ª—å.",
        reply_markup=types.InlineKeyboardMarkup(
            inline_keyboard=[
                [types.InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu:back")]
            ]
        ),
    )
